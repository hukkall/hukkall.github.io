[{"title":"4412的wifi驱动以及管理软件的移植","url":"/2020/02/20/4412的wifi驱动以及管理软件的移植/","content":"#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位  \n\n#### 问题\n\n1. 给的pdf上面的wifi模块的型号不对\n\n   > 它给我的是<img src=\"image-20200219235746812.PNG\" alt=\"image-20200219235746812\" style=\"zoom:33%;\" />这个型号的驱动，实际上开发板上搭载的是\n   >\n   > <img src=\"image-20200219235946818.PNG\" alt=\"image-20200219235946818\" style=\"zoom: 80%;\" />这个型号的驱动\n\n2. 由于缺少`wpa_supplicant`这个管理软件，wifi无法连接到加密的网络\n\n #### 解决过程\n\n​\t\t我仔细地查看开发板，发现开发板搭载的是`rtl8188eus`这个型号的无线模块。知道是什么型号的就好办了，直接开始移植吧。\n\n​\t\t我先从google上找到了驱动源代码的github，clone下载之后，先对`Makefile`进行修改，由于它默认是i386平台，我们需要先对它进行屏蔽，并加入我们的设备。如下图所示：\n\n![image-20200220001655792](image-20200220001655792.PNG)\n\n![image-20200220001636696](image-20200220001636696.PNG)\n\n其中`CONFIG_PLATFORM_ARM_Exynos4412=y`是我们新添加的设备。\n\n​\t\t在1690行附近加入一段判断语句：\n\n`ifeq ($(CONFIG_PLATFORM_ARM_Exynos4412), y)                                 \nEXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN                                  \n ARCH := arm                                                 \nCROSS_COMPILE := arm-none-linux-gnueabi-                                  \nKVER:=3.5.0                                                 \nKSRC :=/home/gukki/HostFiles/A9/SRC/kernel/linux-3.5.0-rc6/                         \nMODULE_NAME :=wlan                                             \nendif`\n\n​\t\t注意`KVER`是你的内核版本号，`KSRC`是你的交叉编译好的内核目录。\n\n​\t\t保存退出之后，直接`make`即可。生成的`wlan.ko`可通过minicom进行传输到开发板上，开发板上使用`insmod wlan.ko`来安装驱动。\n\n​\t\t驱动安装完成之后使用`ifconfig -a`来进行查看自己的无线网卡的名字，并且使用`ifconfig 无线网卡名字 up`来进行启用网卡。\n\n​\t\t驱动完成安装之后，运行`iwconfig`i应该如下所示：\n\n![image-20200220011149442](image-20200220011149442.PNG)\n![image-20200219235529857](image-20200219235529857.png)\n![1](1.png)\n\n-----------------------------------------------------------------------------------------------------------------------------------\n\n​\t\t驱动安装完成之后，我发现这模块只能连接开放的wifi，进过一番google之后发现，我还需要移植一个名为**wpa_supplicant**   的软件来进行管理。而这个软件又依赖于`openssl`这个库，索性一次全部搞定吧。\n\n​\t\t这里我的wpa版本是0.7.2,ssl版本是0.9.8.e。先从网上把他们下载下来。我将他们都解压到一个文件夹里。openssl的移植需要wpa提供的补丁文件。\n\n​\t\t执行命令:\n\n​\t\t\t`cp wpa_supplicant-0.7.2/patches/openssl-0.9.8e-tls-extensions.patch ./openssl-0.9.8e`\n\n​\t\t\t`cd openssl-0.9.8e`\n\n​\t\t\t` patch -p1 < openssl-0.9.8e-tls-extensions.patch`\n\n​\t\t创建一个干净的文件夹，我的路径是`/home/gukki/Cross_Code/Cross/openssl/`，在openssl-0.9.8目录里面运行`Configure`脚本来进行配置`Makefile`：\n\n```shell\n\t\t`./Configure linux-elf-arm -DL_EDNIAN linux:'arm-none-linux-gnueabi-gcc' shared --prefix=/home/gukki/Cross_Code/Cross/openssl/ -lcrypto`\n```\n\n​\t\t配置完成之后就可以`make && make install`了。生成的动态库文件在openssl/lib里面。  \n\n​\t\t接下来进行wpa的移植。  \n\n​\t\t进入wpa的源代码目录，修改`Makefile`文件，注释掉第一和第三行，并将CC改为你的交叉编译器，\n\n在\n    CFLAGS += -I../src\n    CFLAGS += -I../src/utils\n    下添加：\n    CFLAGS += -I/home/gukki/Cross_Code/Cross/openssl/include/\n\n修改\n    LIBS += -lssl\n    为\n    LIBS += -lssl -L/home/gukki/Cross_Code/Cross/openssl/lib/\n\n修改\n    LIBS_p += -lcrypto\n    为\n    LIBS_p += -lcrypto -L/home/gukki/Cross_Code/Cross/openssl/lib/\n\n​\t\t保存并退出，将目录下面的`defconfig`复制为`.config`并执行`make`\n\n​\t\t编译完成之后，将目录下面的`wpa_supplicant`和`wpa_cli`文件拷贝到开发板的`/bin`目录下面。\n\n------------------\n\n​\t\t为了连接上加密的wifi，还需要在开发板的`/etc`目录下面添加wpa-psk-tkip.conf这一配置文件。\n\n我的配置文件如下所示：\n\n```\n WPA-PSK/TKIP\n        ctrl_interface=/var/run/wpa_supplicant\n        network={\n        ssid=\"****\"\n        key_mgmt=WPA-PSK\n        proto=WPA RSN\n        pairwise=CCMP\n        group=CCMP\n        psk=\"***\"\n        }\n\n```\n\n​\t\t其中ssid是你的wifi名字，psk是你的密码。\n\n​\t\t在开发板内创建wpa程序的运行目录：`mkdir /var/run/wpa_supplicant -p`\n\n​\t\t平时使用`wpa_supplicant -B -i wlan0 -c /etc/wpa-psk-tkip.conf`即可连接到wifi。\n\n​\t\t连接到之后需要自己更改ip地址和默认网关。具体操作请自行搜索。\n"},{"title":"Test","url":"/2020/02/19/Test/","content":"#### 题目\n```\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n\n输入: 3\n输出: \"III\"\n示例 2:\n\n输入: 4\n输出: \"IV\"\n示例 3:\n\n输入: 9\n输出: \"IX\"\n示例 4:\n\n输入: 58\n输出: \"LVIII\"\n解释: L = 50, V = 5, III = 3.\n示例 5:\n\n输入: 1994\n输出: \"MCMXCIV\"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n```\n\n#### 思路\n之前做这道题目的时候用了很复杂的方式，一堆一堆的分支条件语句，虽然速度还行，但是代码很不美观。\n\n这次采用贪心的方法，解这道题目一如生活中买东西一样：\n> 如果你需要支付380元给商家，并且你身上有各种面额的钞票。我们一般都会拿取最大面额的钞票给商家：\n先点出三张100，再点出一张50，再各点出一张20和10。\n因为这样选取的钞票最少，选取最方便。\n>\n\n这道题也是如此，表示4的时候不是用4个\"I\"连起来，而是使用\"IV\"来表示。\n所以我们可以将罗马数字的组合拿出来当作我们身上钞票的面额。每一次选择大小最接近源数字的罗马数字，将源数字减去选取的罗马数字对应的值。\n\n#### 代码：\n```\nclass Solution\n{\n\tpublic:\n\t\tstring intToRoman(int num)\n\t\t{\n\t\t\tint nums[]={1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\t\t\tstring roman[]={\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\t\t\tstring res = \"\";\n\t\t\tfor(int i = 0;i<13;i++)\n\t\t\t{\n\t\t\t\twhile(num>=nums[i])\n\t\t\t\t{\n\t\t\t\t\tres+=roman[i];\n\t\t\t\t\tnum-=nums[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n```\n"}]