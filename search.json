[{"title":"基于4412的opencv的移植(附带contrib)","url":"/2020/02/20/基于4412的opencv的移植-附带contrib/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 18.04LTS 64位\n\n#### 使用的工具\n\n1. 2013版的交叉编译工具(arm-2013.05-24-arm-none-linux-gnueabi)\n2. opencv_3.4.9\n3. opencv_contrib_3.4.9\n4. cmake-gui\n\n#### 问题\n\n1. 放假之前用的虚拟机被我删除了，里面的文件都没了。\n2. 开发板的文件系统被我折腾坏了\n3. 需要重新移植opencv\n\n#### 解决过程：\n\n##### 1. 下载所需软件以及源代码\n\n​\t\t首先下载好我们需要使用到的各个文件，他们的下载链接如下所示：\n\n```\narm-2013.05-24-arm-none-linux-gnueabi\t\t链接：arm-2013.05-24-arm-none-linux-gnueabi\nopencv_3.4.9\t链接：https://github.com/opencv/opencv/archive/3.4.9.tar.gz\nopencv_contrib_3.4.9 链接：https://github.com/opencv/opencv_contrib/archive/3.4.9.tar.gz\n```\n\n至于cmake-gui的话，如果你使用的是ububtu，直接在终端输入`sudo apt install cmake-gui`即可。\n\n将交叉编译器解压好，这里我的是`/home/gukki/baidunetdiskdownload/arm-2013.05/`\n\n将下载并解压好的两份源代码放在同一个目录。\n\n##### 2. 使用cmake-gui进行交叉编译\n\n​\t\t打开cmake，如下图所示：（只截取了上半部分）\n\n![image-20200220202805847](/../img/image-20200220202805847.png)\n\n​\t\t第一行是要求你输入你的opencv的源代码的绝对路径，在这里我的路径是`/home/gukki/OpenCv/Source_Code/opencv-3.4.9`，第二行要求你填写配置好的源代码的保存路径。在这里，我的是`/home/gukki/OpenCv/Process_Code`。\n\n​\t\t填写完毕之后点击`Configure`，cmake要求你选择编译工具，由于我们是交叉编译，我们选择最后一项。点击下一步之后如下图所示：\n\n![image-20200220203339941](/../img/image-20200220203339941.png)\n\n​\t\t其中`Operating System`顾名思义，操作系统，我们的开发板上用的是Linux，就写上吧。\n\n`C`要求你指定好交叉编译器的C编译器，也就是arm-gcc的所在地。\n\n`C++`同理，也是要求你填上arm-g++的所在地，而`Target Root`填写上你交叉编译器的目录。\n\n​\t\t填写完成之后点击完成。\n\n​\t\t配置完成之后应该会是一片红色，并且左下角的文本显示区域有一句`Configuring done`。\n\n我们对我们的需求进行对opencv的裁剪：\n\n> 在搜索栏区域输入JPEG,勾选上`BUILD_JPEG`  \n>\n> 输入PNG,勾选上`BULID_PNG`\n>\n> 输入nonfree，勾选上\n>\n> 输入gtk，取消勾选，因为我们用不上图形界面\n>\n> 输入zlib，勾选上\n>\n> 输入extra，在`Value`一栏上点击右边的三个点，定位好你的`opencv_contrib`的`moudules`文件夹。\n>\n> 输入prefix，输入你想安装到的文件夹路径。等会`make install`时会安装到这里。    \n\n​\t\t配置完成之后点击`Configure`，此时你应该要下载一些有关附加模块的一些文件，可能需要很久，等不及的就不去配置extra。下载完成之后，可以再次对额外模块进行裁剪，根据你的需求来定。裁剪完成之后，再次点击`Configure`，应该不会出现红色了。\n\n点击`Generate`生成工程文件。  \n\n##### 3.编译文件\n\n​\t\t进入你的配置好的源代码的文件夹，在此处打开终端，输入`make`开始编译，根据自身虚拟机配置情况，可在后面加上`-j线程数`这个参数，我给虚拟机分配了8个核心，所以我编译速度比较快，只用了5分钟左右。如果你什么都没加，预计时间可能是半小时到一小时左右。中间可能有些警告，无须理会。只要没停下来就好。\n\n![image-20200220210124846](/../img/image-20200220210124846.png)\n\n可以看到处理器是被吃满的。  \n\n​\t\t编译完成后输入`make install`，可能需要你加个`sudo`什么的....\n\n​\t\t安装完成之后可以去设定的`prefix`文件夹去看看。应该长这样：\n\n![image-20200220210712344](/../img/image-20200220210712344.png)\n\n​\t\t其中`lib`里面是我们编译好的库文件，使用`file`命令查看类型：\n\n![image-20200220210841342](/../img/image-20200220210841342.png)\n\n​\t\t成功了大半了！\n\n##### 4. 移植到开发板上\n\n​\t\t将`lib`文件夹里面的所有文件全部传到开发板的`/lib`，目录下面，使用`nfs`速度会快很多。\n\n​\t\t由于我们使用了较新版本的`arm_gcc`编译工具链，我们还需要把交叉编译工具链里面的`libstdc++.so,libstdc++.so.6,libstdc++6.0.17`一起复制过去并覆盖。他们位于`arm-2013.05/arm-none-linux-gnueabi/libc/usr/lib/`这个地方。\n\n##### 5. 虚拟机编译设置\n\n​\t\t为了让虚拟机知道opecv的头文件和库文件的位置，我们需要借助一个叫做`pkg-config` 的软件， 安装也是可以用`apt`来安装的。我们找到opencv库文件夹里面的pkgconfig文件夹，打开你的shell的配置文件，我使用的是`zsh`所以打开`.zshrc`加入以下的两句话句话：\n\n```\nPKG_CONFIG_PATH=/home/gukki/OpenCv/_Install/lib/pkgconfig/:$PKG_CONFIG_PATH\nexport PKG_CONFIG_PATH\n```\n\n​\t\t自行替换你的pkgconfig文件夹位置。\n\n​\t\t使用`source`命令让更改生效，输入`pkg-config --cflags --libs opencv`，应该会出现一大坨东西，如下所示：\n\n![image-20200220212101215](/../img/image-20200220212101215.png)\n\n##### 6. 测试与简化\n\n​\t\t写一个非常简单的程序，来测试下吧：\n\n```c++\n#include<opencv2/opencv.hpp>\nusing namespace cv;\nint main()\n{\n  Mat m;\n  return 0;\n}\n```\n\n​\t\t保存为`T.cpp`，使用如下命令进行编译：\n\n```shell\narm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` T.cpp -lpthread -lrt -ldl \n```\n\n​\t\t应该只有一个警告，不需要理会。\n\n​\t\t生成的`a.out`文件拷贝到开发板，给予权限。运行之后应该什么效果都没有，也没有任何报错。那就是行了。你可以试试更加复杂的程序了。但是不能有任何跟界面有关的函数出现比如`imshow`，`waitkey`等等，否则会报错。（因为我裁剪掉了）你也可以自行尝试如何让他们使用，有更好的想法可以告诉我！\n\n​\t\t每次编译都要打那么长的代码，有没有方法可以简化？\n\n​\t\t可以使用`alias`命令来进行简化，我的就是：\n\n```shell\nalias armcv=\"arm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` -lpthread -ldl -lrt\"\n```\n\n​\t\t同样的，写到你自己的shell的配置文件里面。\n\n​\t\t完-\n\n​\t\t","tags":["嵌入式","软件移植"]},{"title":"4412的wifi驱动以及管理软件的移植","url":"/2020/02/20/4412的wifi驱动以及管理软件的移植/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位  \n\n#### 问题\n\n1. 给的pdf上面的wifi模块的型号不对\n\n   > 它给我的是**rt8723bu**这个型号的驱动，实际上开发板上搭载的是![image-20200219235946818](/../img/image-20200219235946818.png)\n   >\n   > 这个型号的驱动\n\n2. 由于缺少`wpa_supplicant`这个管理软件，wifi无法连接到加密的网络\n\n     \n\n   \n\n #### 解决过程\n\n​\t\t我仔细地查看开发板，发现开发板搭载的是`rtl8188eus`这个型号的无线模块。知道是什么型号的就好办了，直接开始移植吧。\n\n​\t\t我先从google上找到了驱动源代码的[github](https://github.com/quickreflex/rtl8188eus)，clone下载之后，先对`Makefile`进行修改，由于它默认是i386平台，我们需要先对它进行屏蔽，并加入我们的设备。如下图所示：\n\n![image-20200220001655792](/../img/image-20200220001655792.png)\n\n![image-20200220001636696](/../img/image-20200220001636696.png)\n\n其中`CONFIG_PLATFORM_ARM_Exynos4412=y`是我们新添加的设备。\n\n​\t\t在1690行附近加入一段判断语句：\n\n```shell\nifeq ($(CONFIG_PLATFORM_ARM_Exynos4412), y)                                   \nEXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN                                  \n ARCH := arm                                                 \nCROSS_COMPILE := arm-none-linux-gnueabi-                                  \nKVER:=3.5.0                                                 \nKSRC :=/home/gukki/HostFiles/A9/SRC/kernel/linux-3.5.0-rc6/                         \nMODULE_NAME :=wlan                                             \nendif\n```\n\n​\t\t注意`KVER`是你的内核版本号，`KSRC`是你的交叉编译好的内核目录。\n\n​\t\t保存退出之后，直接`make`即可。生成的`wlan.ko`可通过minicom进行传输到开发板上，开发板上使用`insmod wlan.ko`来安装驱动。\n\n​\t\t驱动安装完成之后使用`ifconfig -a`来进行查看自己的无线网卡的名字，并且使用`ifconfig 无线网卡名字 up`来进行启用网卡。\n\n​\t\t驱动完成安装之后，运行`iwconfig`应该如下所示：\n\n![image-20200220011149442](/../img/image-20200220011149442.png)\n\n-----------------------------------------------------------------------------------------------------------------------------------\n\n​\t\t驱动安装完成之后，我发现这模块只能连接开放的wifi，进过一番google之后发现，我还需要移植一个名为[**wpa_supplicant**](https://w1.fi/releases/wpa_supplicant-0.7.2.tar.gz)   的软件来进行管理。而这个软件又依赖于[**openssl**](https://ftp.openssl.org/source/old/0.9.x/openssl-0.9.8e.tar.gz)这个库，索性一次全部搞定吧。\n\n​\t\t这里我的wpa版本是0.7.2,ssl版本是0.9.8.e。先从网上把他们下载下来。我将他们都解压到一个文件夹里。openssl的移植需要wpa提供的补丁文件。\n\n​\t\t执行命令:\n\n​\t\t\t`cp wpa_supplicant-0.7.2/patches/openssl-0.9.8e-tls-extensions.patch ./openssl-0.9.8e`\n\n​\t\t\t`cd openssl-0.9.8e`\n\n​\t\t\t` patch -p1 < openssl-0.9.8e-tls-extensions.patch`\n\n​\t\t创建一个干净的文件夹，我的路径是`/home/gukki/Cross_Code/Cross/openssl/`，在openssl-0.9.8目录里面运行`Configure`脚本来进行配置`Makefile`：\n\n```shell\n\t\t./Configure linux-elf-arm -DL_EDNIAN linux:'arm-none-linux-gnueabi-gcc' shared --prefix=/home/gukki/Cross_Code/Cross/openssl/ -lcrypto\n```\n\n​\t\t配置完成之后就可以`make && make install`了。生成的动态库文件在openssl/lib里面。  \n\n​\t\t接下来进行wpa的移植。  \n\n​\t\t进入wpa的源代码目录，修改`Makefile`文件，注释掉第一和第三行，并将CC改为你的交叉编译器，\n\n在\n  `  CFLAGS += -I../src`\n  `  CFLAGS += -I../src/utils `\n    下添加：\n  `  CFLAGS += -I/home/gukki/Cross_Code/Cross/openssl/include/`\n\n修改\n   ` LIBS += -lssl`\n    为\n    `LIBS += -lssl -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n修改\n   `LIBS_p += -lcrypto`\n    为\n `   LIBS_p += -lcrypto -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n​\t\t保存并退出，将目录下面的`defconfig`复制为`.config`并执行`make`\n\n​\t\t编译完成之后，将目录下面的`wpa_supplicant`和`wpa_cli`文件拷贝到开发板的`/bin`目录下面。\n\n------------------\n\n​\t\t为了连接上加密的wifi，还需要在开发板的`/etc`目录下面添加wpa-psk-tkip.conf这一配置文件。\n\n我的配置文件如下所示：\n\n```\n WPA-PSK/TKIP\n        ctrl_interface=/var/run/wpa_supplicant\n        network={\n        ssid=\"****\"\n        key_mgmt=WPA-PSK\n        proto=WPA RSN\n        pairwise=CCMP\n        group=CCMP\n        psk=\"***\"\n        }\n\n```\n\n​\t\t其中ssid是你的wifi名字，psk是你的密码。\n\n​\t\t在开发板内创建wpa程序的运行目录：`mkdir /var/run/wpa_supplicant -p`\n\n​\t\t平时使用`wpa_supplicant -B -i wlan0 -c /etc/wpa-psk-tkip.conf`即可连接到wifi。\n\n​\t\t连接到之后需要自己更改ip地址和默认网关。具体操作请自行搜索。","tags":["嵌入式","软件移植","驱动移植"]}]