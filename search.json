[{"title":"JWT学习","url":"/2020/06/29/JWT学习/","content":"\n# JWT 学习\n\n## 1、概念\n\n​\t JWT(Jason Web Token)按照我个人理解，是一串服务端按照特定的加密算法生成的字符串。\n\n​\t在用户登录成功之后，服务器将用户的个人信息加密并签名成一串字符串发送回用户浏览器，在每次访问受权限控制的网页的时候将这串字符串发回给服务器，用于证明“你还是你”。然后服务端可以解密这串字符串，从里面拿到用户的相关信息，并判断用户有无权限访问此页面。\n\n​\t绿小萝的开发中，我们采用了传统的session来记录用户信息，这样在本地或者说单机开发是没有什么问题。但是一旦出现前后端分别处于不同的服务器里，产生了跨域的问题，这样的话session就比较难处理了。\n\n​\t采用JWT的话，服务器不保存用户的session，只凭JWT里面的信息来鉴别用户，这样的话，跨域就变得很简单了。\n\n​\tJWT这个字符串由三个结构组成\n\n>- 头部(Header)\n> - \"alg\" 加密类型\n> - \"typ\" 这串token的类型，自然是JWT\n>- 载荷(PayLoad)\n> - 可自定义，采用键值对的方式\n>- 签名\n> - 与服务端指定的密匙有关\n\n​\t附：我们使用的session认证流程：\n\n>1. 用户登录，发送用户名和密码到后台\n>2. 后台验证通过之后，将从数据库取出来的用户信息保存到session里\n>3. 后台向用户浏览器返回一个session_id，写入浏览器的cookie里。\n>4. 之后的每一个请求，都会将cookie里面的session_id发送回后台\n>5. 后台通过前台传来的session_id，找到保存起来的session，并从里面取得用户信息。\n\n## 2、小试牛刀\n\n​\t网上找了个教程，讲的很好，我模仿他的例子，加上了自己理解的注释：\n\n```java\nvoid contextLoads() {\n        String s = genToken();\n        verifyToken(s);\n\n    }\n\t//生成JWT\n    private String genToken() {\n        //先生成token，预设好一个Key\n        String secret = \"imkey\";\n        //加密\n        Algorithm algorithm = Algorithm.HMAC256(secret);\n        //设置头部信息\n        //也就是加密算法类型以及token类型\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"alg\", \"HS256\");\n        map.put(\"typ\", \"JWT\");\n\n        //设置载荷（payload）\n        String token = JWT.create()\n                //定义头部\n                .withHeader(map)\n                //自定义载荷\n                .withClaim(\"name\", \"李一\")\n                //定义主题\n                .withSubject(\"一个token\")\n                //签名头部\n                .sign(algorithm);\n        return token;\n    }\n\t//校验JWT\n    private void verifyToken(String token){\n        //定义加密类型\n        Algorithm algorithm = Algorithm.HMAC256(\"imkey\");\n        //获取这种算法的对应的解密（校验）对象\n        JWTVerifier require = JWT.require(algorithm)\n                .build();\n        System.out.println(require);\n        //解密\n        DecodedJWT decodedJWT = require.verify(token);\n        //获取载荷里面的值\n        Claim claim = decodedJWT.getClaim(\"name\");\n        System.out.println(claim);\n        //输出载荷的值\n        System.out.println(claim.asString());\n    }\n```\n\n运行结果如下：\n\n![image-20200626083111707](/img/image-20200626083111707-1593413542002.png)\n\n是没有问题的。\n\n## 3、使用ajax发送用户信息并进行登录认证的JWT应用\n\n​\t\t项目结构如下所示\n\n![image-20200626122914327](/img/image-20200626122914327.png)\n\n流程图（[引用了一个大佬的图](https://www.cnblogs.com/fishpro/p/spring-boot-study-securing-jwt.html)，详情请见本章末尾）\n\n![o_jwt2](/img/o_jwt2.jpg)\n\n![o_jwt3](/img/o_jwt3.jpg)\n\n![o_jwt4](/img/o_jwt4.jpg)\n\n**JwtAuthenticationController**\n\n```java\n/**\n * 用于验证 jwt 返回客户端 jwt（json web token）\n * */\n@RestController\n@CrossOrigin\npublic class JwtAuthenticationController {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private JwtUserDetailsService userDetailsService;\n\n    /**\n     * 获取 客户端来的 username password 使用秘钥加密成 json web token\n     * */\n    @RequestMapping(value = \"/authenticate\", method = RequestMethod.POST)\n    public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {\n        //获取前台传来的明文账号密码并进行认证\n        authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());\n        //认证操作成功后，以下的语句才会执行\n\n\n        //获取用户信息\n        final UserDetails userDetails = userDetailsService\n                .loadUserByUsername(authenticationRequest.getUsername());\n        //生成token\n        final String token = jwtTokenUtil.generateToken(userDetails);\n        //向前台返回序列化后的token\n        return ResponseEntity.ok(new JwtResponse(token));\n    }\n\n    /**\n     *  获取 客户端来的 username password 使用秘钥加密成 json web token\n     * */\n    private void authenticate(String username, String password) throws Exception {\n        try {\n            //创建一个没有认证的token实例，此时“是否身份认证过”属性为false\n            //由于此时未进行身份认证，所以他的权限未知\n\n            //认证信息管理（authenticationManager），从指定的用户数据源加载用户信息\n            //然后使用约定好的加密方式，进行认证。\n            //认证失败之后，直接返回给前台401\n            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));\n        } catch (DisabledException e) {\n            throw new Exception(\"USER_DISABLED\", e);\n        } catch (BadCredentialsException e) {\n            throw new Exception(\"INVALID_CREDENTIALS\", e);\n        }\n    }\n}\n```\n\n**JwtAuthenticationEntryPoint**\n\n```java\n/**\n * AuthenticationEntryPoint 用来解决匿名用户访问无权限资源时的异常\n * AccessDeineHandler 用来解决认证过的用户访问无权限资源时的异常\n * */\n@Component\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n\n    private static final long serialVersionUID = -7858869558953243875L;\n\n    //当出错的时候 发送 Unauthorized\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response,\n                         AuthenticationException authException) throws IOException {\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n    }\n}\n\n```\n\n**JwtRequestFilter**\n\n```java\n/**\n * 过滤器 用于 Spring Boot Security\n * OncePerRequestFilter 一次请求只通过一次filter，而不需要重复执行\n * */\n@Component\npublic class JwtRequestFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtUserDetailsService jwtUserDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws ServletException, IOException {\n        //获得请求头\n        final String requestTokenHeader = request.getHeader(\"Authorization\");\n\n        String username = null;\n        String jwtToken = null;\n        // JWT Token 获取请求头部的 Bearer\n        // only the Token\n        if (requestTokenHeader != null && requestTokenHeader.startsWith(\"Bearer \")) {\n            jwtToken = requestTokenHeader.substring(7);\n            try {\n                //从token里获取用户名\n                username = jwtTokenUtil.getUsernameFromToken(jwtToken);\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"Unable to get JWT Token\");\n            } catch (ExpiredJwtException e) {\n                System.out.println(\"JWT Token has expired\");\n            }\n        } else {\n            logger.warn(\"JWT Token does not begin with Bearer String\");\n        }\n\n        // 验证\n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n            //我猜，之所以要在这里再校验一次用户名，是防止上面的异常抛出的后，username为空的情况。\n            //获取用户的在后台保存的账号密码，封装成一个对象，通过查询用户名的方式\n            UserDetails userDetails = this.jwtUserDetailsService.loadUserByUsername(username);\n\n            // JWT 验证通过 使用Spring Security 管理\n            //将token里面的用户名和保存的对象进行校验\n            if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {\n                //传入用户信息，\n                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(\n                        userDetails, null, userDetails.getAuthorities());\n                usernamePasswordAuthenticationToken\n                        .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                // After setting the Authentication in the context, we specify\n                // that the current user is authenticated. So it passes the\n                // Spring Security Configurations successfully.\n                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n            }\n        }\n        //没有token，则跑去jwtcontroller\n        chain.doFilter(request, response);\n    }\n\n}\n```\n\n**JwtUserDetailsService**\n\n```java\n//用户信息来源\n@Service\npublic class JwtUserDetailsService implements UserDetailsService {\n//通过用户名加载\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        if (\"javainuse\".equals(username)) {\n            //新建一个用户名为：javainuse的用户，密码为用BC加密的password,后面的数组是这个用户的权限列表，目前为空。\n            //BC加密后的字符串有着它特殊的意思，前面的2a表示使用了bc加密，后面的10表示它hash了10次\n            //然后从第三个$开始算起的21个字符都是它的salt，用于混淆用的\n            //后面的全都是密文密码和slat hash10次之后的密文\n            //如何校验？\n            //获得前台传来的明文密码，取储存好的BC加密后的字符串，取其中的盐，hash10次之后，和密文进行匹配。\n\n\n            //返回用户的用户名、BC加密后的密码、以及权限列表。\n            return new User(\"javainuse\", \"$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6\",\n                    new ArrayList<>());\n        } else {\n            throw new UsernameNotFoundException(\"User not found with username: \" + username);\n        }\n    }\n}\n\n```\n\n**WebSecurityConfig**\n\n```java\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n\n    @Autowired\n    private UserDetailsService jwtUserDetailsService;\n\n    @Autowired\n    private JwtRequestFilter jwtRequestFilter;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        // configure AuthenticationManager so that it knows from where to load\n        // user for matching credentials\n        // Use BCryptPasswordEncoder\n        //配置用于用户信息来源，并设置好加密方式\n        auth.userDetailsService(jwtUserDetailsService).passwordEncoder(passwordEncoder());\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        // 本示例不需要使用CSRF\n        httpSecurity.csrf().disable()\n                // 认证页面不需要权限\n                .authorizeRequests().antMatchers(\"/authenticate\").permitAll().\n                //其他页面\n                        anyRequest().authenticated().and().\n                //登录页面 模拟客户端\n                formLogin().loginPage(\"/login.html\").permitAll().and().\n                // store user's state.\n                 exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().sessionManagement()\n                //不使用session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n        //验证请求是否正确\n        httpSecurity.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n}\n```\n\n**HelloWorldController**\n\n```java\n@RestController\npublic class HelloWorldController {\n\n    @RequestMapping({ \"/hello\" })\n    public String firstPage() {\n        return \"Hello World\";\n    }\n\n}\n```\n\n**JwtRequest**\n\n```java\npublic class JwtRequest{\n\n   // private static final long serialVersionUID = 5926468583005150707L;\n\n    private String username;\n    private String password;\n\n    //need default constructor for JSON Parsing\n    public JwtRequest()\n    {\n\n    }\n\n    public JwtRequest(String username, String password) {\n        this.setUsername(username);\n        this.setPassword(password);\n    }\n\n    public String getUsername() {\n        return this.username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return this.password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n```\n\n**JwtResponse**\n\n```java\npublic class JwtResponse implements Serializable {\n\n    private static final long serialVersionUID = -8091879091924046844L;\n    private final String jwttoken;\n\n    public JwtResponse(String jwttoken) {\n        this.jwttoken = jwttoken;\n    }\n\n    public String getToken() {\n        return this.jwttoken;\n    }\n}\n```\n\n**JwtTokenUtil**\n\n```java\n@Component\npublic class JwtTokenUtil implements Serializable {\n\n    private static final long serialVersionUID = -2550185165626007488L;\n\n    public static final long JWT_TOKEN_VALIDITY = 5 * 60 * 60;\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    //retrieve username from jwt token\n    public String getUsernameFromToken(String token) {\n        return getClaimFromToken(token, Claims::getSubject);\n    }\n\n    //retrieve expiration date from jwt token\n    public Date getExpirationDateFromToken(String token) {\n        return getClaimFromToken(token, Claims::getExpiration);\n    }\n\n    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\n        final Claims claims = getAllClaimsFromToken(token);\n        return claimsResolver.apply(claims);\n    }\n    //for retrieveing any information from token we will need the secret key\n    private Claims getAllClaimsFromToken(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n    }\n\n    //check if the token has expired\n    private Boolean isTokenExpired(String token) {\n        final Date expiration = getExpirationDateFromToken(token);\n        return expiration.before(new Date());\n    }\n\n    //generate token for user\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        return doGenerateToken(claims, userDetails.getUsername());\n    }\n\n    //while creating the token -\n    //1. Define  claims of the token, like Issuer, Expiration, Subject, and the ID\n    //2. Sign the JWT using the HS512 algorithm and secret key.\n    //3. According to JWS Compact Serialization(https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-3.1)\n    //   compaction of the JWT to a URL-safe string\n    private String doGenerateToken(Map<String, Object> claims, String subject) {\n\n        return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * 1000))\n                .signWith(SignatureAlgorithm.HS512, secret).compact();\n    }\n\n    //校验 token\n    public Boolean validateToken(String token, UserDetails userDetails) {\n        //获取token的用户名，并进行匹配\n        final String username = getUsernameFromToken(token);\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\n    }\n}\n\n```\n\n登录用的ajax：\n\n```javascript\n$(function() {\n        $(\"#btnSave\").click(function () {\n            var username=$(\"#userName\").val();\n            var password=$(\"#password\").val();\n            $.ajax({\n                cache: true,\n                type: \"POST\",\n                url: \"/authenticate\",\n                contentType: \"application/json;charset=UTF-8\",\n                data:JSON.stringify({\"username\":username ,\"password\" : password}),\n                dataType: \"json\",\n                async: false,\n                error: function (request) {\n                    console.log(\"Connection error\");\n                },\n                success: function (data) {\n                    //save token\n                    localStorage.setItem(\"token\",data.token);\n\n\n                }\n            });\n        });\n    });\n```\n\n注意，这个项目的java版本要求是java8，如果你是和我一样使用java11或更高的版本的话，可以使用我的pom.xml里面的配置。\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>javax.xml.bind</groupId>\n            <artifactId>jaxb-api</artifactId>\n            <version>2.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.sun.xml.bind</groupId>\n            <artifactId>jaxb-impl</artifactId>\n            <version>2.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.sun.xml.bind</groupId>\n            <artifactId>jaxb-core</artifactId>\n            <version>2.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.activation</groupId>\n            <artifactId>activation</artifactId>\n            <version>1.1.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt</artifactId>\n            <version>0.9.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n参考来源：\n\n[Spring Boot Security JWT 整合实现前后端分离认证示例](https://www.cnblogs.com/fishpro/p/spring-boot-study-securing-jwt.html)\n\n[Spring Boot Security + JWT Hello World Example](https://www.javainuse.com/spring/boot-jwt)\n\n\n\n## 4、 JWT+数据库 授权部分\n\n​\t我觉得这玩意可难了，学了个两天才勉勉强强搞明白个一小半。唉，吃了英语不好的亏。\n\n​\t以下是大概的流程：\n\n<img src=\"/img/image-20200628170759526.png\" alt=\"A\" style=\"zoom: 100%;\" />\n\n所用到的类：\n\n### 拦截器类 JWTAuthenticationTokenFilter\n\n```java\npublic class JWTAuthenticationTokenFilter extends BasicAuthenticationFilter {\n\n    public JWTAuthenticationTokenFilter(AuthenticationManager authenticationManager) {\n        super(authenticationManager);\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        // 获取请求头中JWT的Token\n        String tokenHeader = request.getHeader(JWTConfig.tokenHeader);\n        // && tokenHeader.startsWith(JWTConfig.tokenPrefix)\n        if (null!=tokenHeader) {\n            try {\n                // 截取JWT前缀\n                String token = tokenHeader.replace(\"Bearer Sans-\", \"\");\n                // 解析JWT\n                Claims claims = Jwts.parser()\n                        .setSigningKey(JWTConfig.secret)\n                        .parseClaimsJws(token)\n                        .getBody();\n                log.info(claims.toString());\n                // 获取用户名\n                String username = claims.getSubject();\n                String userId=claims.getId();\n                if(!StringUtils.isEmpty(username)&&!StringUtils.isEmpty(userId)) {\n                    // 获取角色\n                    List<GrantedAuthority> authorities = new ArrayList<>();\n                    String authority = claims.get(\"authorities\").toString();\n                    log.info(authority);\n                    if(!StringUtils.isEmpty(authority)){\n                        List<Map<String,String>> authorityMap = JSONObject.parseObject(authority, List.class);\n                        for (Map<String, String> stringStringMap : authorityMap) {\n                            for (String s : stringStringMap.keySet()) {\n                                log.info(s);\n                                log.info(stringStringMap.get(s));\n                            }\n                        }\n                        for(Map<String,String> role : authorityMap){\n                            if(!StringUtils.isEmpty(role)) {\n                                authorities.add(new SimpleGrantedAuthority(role.get(\"authority\")));\n                                //log.info(role.get(\"authority\"));\n                            }\n                        }\n                    }\n                    //组装参数\n                    SelfUserEntity selfUserEntity = new SelfUserEntity();\n                    selfUserEntity.setUsername(claims.getSubject());\n                    selfUserEntity.setUserId(Long.parseLong(claims.getId()));\n                    selfUserEntity.setAuthorities(authorities);\n                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(selfUserEntity, userId, authorities);\n                    SecurityContextHolder.getContext().setAuthentication(authentication);\n                }\n            } catch (ExpiredJwtException e){\n                log.info(\"Token过期\");\n            } catch (Exception e) {\n                log.error(e.getMessage());\n                log.info(\"Token无效\");\n            }\n        }\n        filterChain.doFilter(request, response);\n        return;\n    }\n}\n```\n\n### Security配置类 SecurityConfig\n\n```java\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true) //开启权限注解,默认是关闭的\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * 自定义登录成功处理器\n     */\n    @Autowired\n    private UserLoginSuccessHandler userLoginSuccessHandler;\n    /**\n     * 自定义登录失败处理器\n     */\n    @Autowired\n    private UserLoginFailureHandler userLoginFailureHandler;\n    /**\n     * 自定义注销成功处理器\n     */\n    @Autowired\n    private UserLogoutSuccessHandler userLogoutSuccessHandler;\n    /**\n     * 自定义暂无权限处理器\n     */\n    @Autowired\n    private UserAuthAccessDeniedHandler userAuthAccessDeniedHandler;\n    /**\n     * 自定义未登录的处理器\n     */\n    @Autowired\n    private UserAuthenticationEntryPointHandler userAuthenticationEntryPointHandler;\n    /**\n     * 自定义登录逻辑验证器\n     */\n    @Autowired\n    private UserAuthenticationProvider userAuthenticationProvider;\n\n    /**\n     * 加密方式\n     * @Author Sans\n     * @CreateTime 2019/10/1 14:00\n     */\n    @Bean\n    public BCryptPasswordEncoder bCryptPasswordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n    /**\n     * 注入自定义PermissionEvaluator\n     */\n    @Bean\n    public DefaultWebSecurityExpressionHandler userSecurityExpressionHandler(){\n        DefaultWebSecurityExpressionHandler handler = new DefaultWebSecurityExpressionHandler();\n        handler.setPermissionEvaluator(new UserPermissionEvaluator());\n        return handler;\n    }\n\n    /**\n     * 配置登录验证逻辑\n     */\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth){\n        //这里可启用我们自己的登陆验证逻辑\n        auth.authenticationProvider(userAuthenticationProvider);\n    }\n    /**\n     * 配置security的控制逻辑\n     * @Author Sans\n     * @CreateTime 2019/10/1 16:56\n     * @Param  http 请求\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                // 不进行权限验证的请求或资源(从配置文件中读取)\n               .antMatchers(JWTConfig.antMatchers.split(\",\")).permitAll()\n                // 其他的需要登陆后才能访问\n                .anyRequest().authenticated()\n                .and()\n                // 配置未登录自定义处理类\n                .httpBasic().authenticationEntryPoint(userAuthenticationEntryPointHandler)\n                .and()\n                // 配置登录地址\n                .formLogin()\n                .loginProcessingUrl(\"/login/userLogin\")\n                // 配置登录成功自定义处理类\n                .successHandler(userLoginSuccessHandler)\n                // 配置登录失败自定义处理类\n                .failureHandler(userLoginFailureHandler)\n                .and()\n                // 配置登出地址\n                .logout()\n                .logoutUrl(\"/login/userLogout\")\n                // 配置用户登出自定义处理类\n                .logoutSuccessHandler(userLogoutSuccessHandler)\n                .and()\n                // 配置没有权限自定义处理类\n                .exceptionHandling().accessDeniedHandler(userAuthAccessDeniedHandler)\n                .and()\n                // 开启跨域\n                .cors()\n                .and()\n                // 取消跨站请求伪造防护\n                .csrf().disable();\n\n        // 基于Token不需要session\n        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // 禁用缓存\n        http.headers().cacheControl();\n        // 添加JWT过滤器\n        http.addFilter(new JWTAuthenticationTokenFilter(authenticationManager()));\n    }\n}\n```\n\n\n\n### 角色实体类 SysRoleEntity\n\n```java\n@Data\n@TableName(\"sys_role\")\npublic class SysRoleEntity implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\t/**\n\t * 角色ID\n\t */\n\t@TableId\n\tprivate Long roleId;\n\t/**\n\t * 角色名称\n\t */\n\tprivate String roleName;\n}\n```\n\n\n\n###  自定义认证逻辑处理器 UserAuthenticationProvider\n\n```java\npublic class UserAuthenticationProvider implements AuthenticationProvider {\n    @Autowired\n    private SelfUserDetailsService selfUserDetailsService;\n    @Autowired\n    private SysUserService sysUserService;\n    //authentication 这个参数是哪里来的呢？\n    //我猜测是这样的：UsernamePasswordAuthenticationFilter 处理了从前台传入的账号密码，封装成一个实现了Authentication接口的UsernamePasswordAuthenticationToken类，此时这个账号密码尚未认证，所以没有权限。->调用ProviderManager类的authenticate方法处理Token->轮询在security配置里面注册好的登录逻辑处理类，检查是否支持当前token，找到之后进行处理。—>于是，这个token就传进来了。\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        // 获取表单输入中返回的用户名\n        String userName = (String) authentication.getPrincipal();\n        // 获取表单中输入的密码\n        String password = (String) authentication.getCredentials();\n        // 查询用户是否存在\n        SelfUserEntity userInfo = selfUserDetailsService.loadUserByUsername(userName);\n        if (userInfo == null) {\n            throw new UsernameNotFoundException(\"用户名不存在\");\n        }\n        // 我们还要判断密码是否正确，这里我们的密码使用BCryptPasswordEncoder进行加密的\n        if (!new BCryptPasswordEncoder().matches(password, userInfo.getPassword())) {\n            throw new BadCredentialsException(\"密码不正确\");\n        }\n        // 还可以加一些其他信息的判断，比如用户账号已停用等判断\n        if (userInfo.getStatus().equals(\"PROHIBIT\")){\n            throw new LockedException(\"该用户已被冻结\");\n        }\n        // 角色集合\n        Set<GrantedAuthority> authorities = new HashSet<>();\n        // 查询用户角色\n        //一张表储存了用户id和他的所拥有的权限的id，另一张表储存了对应权限id的权限名。\n        //所以查出来是一列权限实体类\n       \n        List<SysRoleEntity> sysRoleEntityList = sysUserService.selectSysRoleByUserId(userInfo.getUserId());\n        for (SysRoleEntity sysRoleEntity: sysRoleEntityList){\n            authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + sysRoleEntity.getRoleName()));\n        }\n        userInfo.setAuthorities(authorities);\n        // 进行登录\n        //上方所说的轮询并检测是否成功的标志就是看返回的是不是为null,不为null则表明认证成功。\n        return new UsernamePasswordAuthenticationToken(userInfo, password, authorities);\n    }\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return true;\n    }\n}\n```\n\n### 查询用户是否存在 SelfUserDetailsService\n\n```java\npublic class SelfUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private SysUserService sysUserService;\n\n    /**\n     * 查询用户信息\n     * @Author Sans\n     * @CreateTime 2019/9/13 17:23\n     * @Param  username  用户名\n     * @Return UserDetails SpringSecurity用户信息\n     */\n    @Override\n    public SelfUserEntity loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 查询用户信息\n        SysUserEntity sysUserEntity =sysUserService.selectUserByName(username);\n        if (sysUserEntity!=null){\n            // 组装参数\n            SelfUserEntity selfUserEntity = new SelfUserEntity();\n            BeanUtils.copyProperties(sysUserEntity,selfUserEntity);\n            return selfUserEntity;\n        }\n        return null;\n    }\n}\n```\n\n### 符合Security标准的用户类 SelfUserEntity\n\n```java\n@Data\npublic class SelfUserEntity implements Serializable, UserDetails {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * 用户ID\n\t */\n\tprivate Long userId;\n\t/**\n\t * 用户名\n\t */\n\tprivate String username;\n\t/**\n\t * 密码\n\t */\n\tprivate String password;\n\t/**\n\t * 状态:NORMAL正常  PROHIBIT禁用\n\t */\n\tprivate String status;\n\n\n\t/**\n\t * 用户角色\n\t */\n\tprivate Collection<GrantedAuthority> authorities;\n\t/**\n\t * 账户是否过期\n\t */\n\tprivate boolean isAccountNonExpired = false;\n\t/**\n\t * 账户是否被锁定\n\t */\n\tprivate boolean isAccountNonLocked = false;\n\t/**\n\t * 证书是否过期\n\t */\n\tprivate boolean isCredentialsNonExpired = false;\n\t/**\n\t * 账户是否有效\n\t */\n\tprivate boolean isEnabled = true;\n\n\n\t@Override\n\tpublic Collection<GrantedAuthority> getAuthorities() {\n\t\treturn authorities;\n\t}\n\t@Override\n\tpublic boolean isAccountNonExpired() {\n\t\treturn isAccountNonExpired;\n\t}\n\t@Override\n\tpublic boolean isAccountNonLocked() {\n\t\treturn isAccountNonLocked;\n\t}\n\t@Override\n\tpublic boolean isCredentialsNonExpired() {\n\t\treturn isCredentialsNonExpired;\n\t}\n\t@Override\n\tpublic boolean isEnabled() {\n\t\treturn isEnabled;\n\t}\n}\n```\n\n### 登录成功处理类 UserLoginSuccessHandler\n\n```java\n@Slf4j\n@Component\npublic class UserLoginSuccessHandler implements AuthenticationSuccessHandler {\n    /**\n     * 登录成功返回结果\n     * @Author Sans\n     * @CreateTime 2019/10/3 9:27\n     */\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication){\n        // 组装JWT\n        //在认证处理器部分，将userinfo传入给UsernamePasswordAuthenticationToken作为principal\n        SelfUserEntity selfUserEntity =  (SelfUserEntity) authentication.getPrincipal();\n        String token = JWTTokenUtil.createAccessToken(selfUserEntity);\n        log.info(selfUserEntity.toString());\n        token = JWTConfig.tokenPrefix + token;\n        // 封装返回参数\n        Map<String,Object> resultData = new HashMap<>();\n        resultData.put(\"code\",\"200\");\n        resultData.put(\"msg\", \"登录成功\");\n        resultData.put(\"token\",token);\n        ResultUtil.responseJson(response,resultData);\n    }\n}\n```\n\n### 与JWT有关的工具类 JWTTokenUtil\n\n```java\n@Slf4j\npublic class JWTTokenUtil {\n\n    /**\n     * 私有化构造器\n     */\n    private JWTTokenUtil(){}\n\n    /**\n     * 生成Token\n     * @Author Sans\n     * @CreateTime 2019/10/2 12:16\n     * @Param  selfUserEntity 用户安全实体\n     * @Return Token\n     */\n    public static String createAccessToken(SelfUserEntity selfUserEntity){\n        // 登陆成功生成JWT\n        String token = Jwts.builder()\n                // 放入用户名和用户ID\n                .setId(selfUserEntity.getUserId()+\"\")\n                // 主题\n                .setSubject(selfUserEntity.getUsername())\n                // 签发时间\n                .setIssuedAt(new Date())\n                // 签发者\n                .setIssuer(\"sans\")\n                // 自定义属性 放入用户拥有权限\n            \t//重申一遍，多角色的时候，这个属性长[{\"authority\":\"ROLE_USER\"},{\"authority\":\"ROLE_ADMIN\"}]这样，表明他有两个角色\n                .claim(\"authorities\", JSON.toJSONString(selfUserEntity.getAuthorities()))\n                // 失效时间\n                .setExpiration(new Date(System.currentTimeMillis() + JWTConfig.expiration))\n                // 签名算法和密钥\n                .signWith(SignatureAlgorithm.HS512, JWTConfig.secret)\n                .compact();\n        log.info(JSON.toJSONString(selfUserEntity.getAuthorities()));\n        return token;\n    }\n}\n```\n\n## 5、JWT+数据库 鉴权部分\n\n上图\n\n<img src=\"/img/image-20200629141557755.png\" alt=\"image-20200629141557755\" style=\"zoom:80%;\" />\n\n\n\n用到的类\n\n### hasPermission 鉴权类 UserPermissionEvaluator\n\n```java \n@Component\n@Slf4j\npublic class UserPermissionEvaluator implements PermissionEvaluator {\n    @Autowired\n    private SysUserService sysUserService;\n    /**\n     * hasPermission鉴权方法\n     * 这里仅仅判断PreAuthorize注解中的权限表达式\n     * 实际中可以根据业务需求设计数据库通过targetUrl和permission做更复杂鉴权\n     * 当然targetUrl不一定是URL可以是数据Id还可以是管理员标识等,这里根据需求自行设计\n     * @Author Sans\n     * @CreateTime 2019/10/6 18:25\n     * @Param  authentication  用户身份(在使用hasPermission表达式时Authentication参数默认会自动带上)\n     * @Param  targetUrl  请求路径\n     * @Param  permission 请求路径权限\n     * @Return boolean 是否通过\n     */\n    @Override\n    //传入用户安全信息、目标url、需要的权限\n    public boolean hasPermission(Authentication authentication, Object targetUrl, Object permission) {\n        // 获取用户信息\n        SelfUserEntity selfUserEntity =(SelfUserEntity) authentication.getPrincipal();\n        Collection<GrantedAuthority> authorities = selfUserEntity.getAuthorities();\n        for (GrantedAuthority authority : authorities) {\n            log.info(authority.getAuthority());\n        }\n        // 查询用户权限(这里可以将权限放入缓存中提升效率)\n        Set<String> permissions = new HashSet<>();\n        //role，权限表，表示有什么权限\n        //menu，功能表，表示能做什么\n        //role_menu表，表示什么权限能做什么事情\n        //user，用户表，表示你是谁\n        //user_role表，表示你有什么权限\n        //          SELECT DISTINCT m.* FROM sys_user_role ur\n        //\t\t\tLEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n        //\t\t\tLEFT JOIN sys_menu m ON rm.menu_id = m.menu_id\n        //\t\t    WHERE ur.user_id = #{userId}\n        //通过用户的id，查询他能干什么。\n        List<SysMenuEntity> sysMenuEntityList = sysUserService.selectSysMenuByUserId(selfUserEntity.getUserId());\n        for (SysMenuEntity sysMenuEntity:sysMenuEntityList) {\n            permissions.add(sysMenuEntity.getPermission());\n        }\n        // 权限对比\n        if (permissions.contains(permission.toString())){\n            return true;\n        }\n        return false;\n    }\n    @Override\n    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {\n        return false;\n    }\n}\n```\n\n**详细代码与注释**：[Gitee](https://gitee.com/gukkibokou/spring-boot-security-demo)","tags":["JavaWeb开发","SpringSecurity","JWT"]},{"title":"博创4412开发板移植最新的ssh","url":"/2020/03/26/博创4412开发板移植最新的ssh/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位 \n\n#### 问题\n\n1. 串口的缺点实在是让人难以忍受\n\n#### 工具和软件\n\n1. 2009q3的交叉编译工具\n2. [OpenSSL-1.1.1e](https://www.openssl.org/source/openssl-1.1.1e.tar.gz)\n3. [OpenSSH-8.2p1](ftp://mirror.internode.on.net/pub/OpenBSD/OpenSSH/portable/openssh-8.2p1.tar.gz)\n4. [zlib-1.2.11](http://www.zlib.net/zlib-1.2.11.tar.gz)\n\n#### 移植过程\n\n##### 前期准备\n\n​\t先从他们各自的官网上下下来源代码。为了确保工作目录的干净，我将源码都保存在一个叫做**Source_Code**的目录下，并且事先创建好**Cross**这个目录，用于保存编译好的库和文件。\n\n##### 编译zlib\n\n​\t进入zlib的源代码目录，执行`./configure --prefix=/home/gukki/Cross_Code/Cross/zlib`进行对`install`目录的指定以及`Makefile`的生成。\n\n​\t对`Makefile`进行修改：\n\n> 在开头加入`CROSS=arm-none-linux-gnueabi-`\n>\n> 将`CC=gcc` 修改为`CC=$(CROSS)gcc`\n>\n> 将`LDSHARED=gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map` 修改为\n>\n> `$(CROSS)gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map`\n>\n> 将`CPP=gcc -E` 修改为 `CPP=$(CROSS)gcc -E`\n>\n> 将`AR=ar`修改为 `AR=$(CROSS)ar`\n\n如下图所示：\n\n![image-20200326180038383](/../img/image-20200326180038383.png)\n\n保存并退出之后执行`make && make install`，这样的话就将编译好的zlib安装到**Cross**目录下的**zlib**。\n\n##### 编译openssl\n\n​\t进入openssl的源代码目录，执行\n\n```shell\n./Configure linux-armv4 no-asm shared --prefix=/home/gukki/Cross_Code CROSS_COMPILE=/home/gukki/baidunetdiskdownload/arm-2009q3/bin/arm-none-linux-gnueabi- CC=gcc\n```\n\n其中：\n\n​\t`linux-armv4`指定了目标平台\n\n​\t`no-asm`表明不生成汇编代码加速\n\n​\t`shared` 表明生成动态链接库\n\n​\t`prefix`指定了安装目录\n\n​\t`CROSS_COMPILE`使用绝对路径制定了交叉编译器的目录。\n\n​\t`CC` 指定了使用gcc\n\n执行`make && make install`，将编译好的库安装到了预先指定好的目录了。\n\n##### 编译openssh\n\n​\t进入openssh的源代码目录，执行\n\n```shell\n./configure --host=arm-none-linux-gnueabi --with-libs --with-zlib=/home/gukki/Cross_Code/Cross/zlib --with-ssl-dir=/home/gukki/Cross_Code/Cross/openssl1.1.1 --disable-etc-default-login CC=arm-none-linux-gnueabi-gcc AR=arm-none-linux-gnueabi-ar\n```\n\n这个就不用多说了，都是指定之前编译好的库的所在地以及交叉编译器。\n\n​\t执行`make` ，不要执行`make install`，否则他会将你生成的程序安装到主机上。\n\n​\t生成结束之后，我是用了网上的一个大佬的脚本，一键打包好所有东西，生成`usr.tar.bz2`。\n\n``` shell\n#!/bin/bash\nfile_a=\"scp sftp ssh ssh-add ssh-agent ssh-keygen ssh-keyscan\" \nfile_b=\"moduli ssh_config sshd_config\" \nfile_c=\"sftp-server ssh-keysign\"\nkey=\"ssh_host_rsa_key ssh_host_dsa_key ssh_host_ecdsa_key ssh_host_ed25519_key\" \n \nmkdir -p usr/local/bin usr/local/etc usr/libexec \nmkdir usr/sbin/\n \nfor i in $file_a\ndo\n\tif [ -f $i ];then\n\t\tcp $i usr/local/bin/\n\t\techo \"cp $i ok\" \n\telse\n\t\techo \"error:$i not exist \"\n        exit_script  \n\tfi\ndone\n \nfor i in $file_b\ndo\n\tif [ -f $i ];then\n\t\tcp $i usr/local/etc/\n\t\techo \"cp $i ok\"\n\telse\n\t\techo \"error:$i not exist\"\n\t\texit_script\n \tfi\ndone\n \nfor i in $file_c\ndo\n    if [ -f $i ];then\n        cp $i usr/libexec\n        echo \"cp $i ok\"\n    else\n        echo \"error:$i not exist\"\n        exit_script\n    fi\ndone\n \nif [ -f \"sshd\" ];then\n\tcp sshd usr/sbin/\n\techo \"cp sshd ok\"\nelse\n\techo \"error:sshd not exist\"\n\texit_script\nfi\n \n# ssh_host_rsa_key\nif [ -f \"ssh_host_rsa_key\" ];then\n\techo \"ssh_host_rsa_key exist\"\n\tcp ssh_host_rsa_key usr/local/etc/\n\techo \"cp ssh_host_rsa_key ok\" \nelse\n\tssh-keygen -t rsa -f ssh_host_rsa_key -N \"\"\n\tcp ssh_host_rsa_key usr/local/etc/\n\techo \"cp ssh_host_rsa_key ok\" \nfi\n \n# ssh_host_dsa_key\nif [ -f \"ssh_host_dsa_key\" ];then\n\techo \"ssh_host_dsa_key exist\"\n\tcp ssh_host_dsa_key usr/local/etc/\n\techo \"cp ssh_host_dsa_key ok\" \nelse\n\tssh-keygen -t dsa -f ssh_host_dsa_key -N \"\"\n\tcp ssh_host_dsa_key usr/local/etc/\n\techo \"cp ssh_host_dsa_key ok\" \nfi\n \n# ssh_host_ecdsa_key\nif [ -f \"ssh_host_ecdsa_key\" ];then\n\techo \"ssh_host_ecdsa_key exist\"\n\tcp ssh_host_ecdsa_key usr/local/etc/\n\techo \"cp ssh_host_ecdsa_key ok\" \nelse\n\tssh-keygen -t ecdsa -f ssh_host_ecdsa_key -N \"\"\n\tcp ssh_host_ecdsa_key usr/local/etc/\n\techo \"cp ssh_host_ecdsa_key ok\" \nfi\n \n# ssh_host_ed25519_key\nif [ -f \"ssh_host_ed25519_key\" ];then\n\techo \"ssh_host_ed25519_key exist\"\n\tchmod 600 ssh_host_ed25519_key\n\tcp ssh_host_ed25519_key usr/local/etc/\n\techo \"cp ssh_host_ed25519_key ok\" \nelse\n\tssh-keygen -t dsa -f ssh_host_ed25519_key -N \"\"\n\tchmod 600 ssh_host_ed25519_key\n\tcp ssh_host_ed25519_key usr/local/etc/\n\techo \"cp ssh_host_ed25519_key ok\" \nfi\n \ntar -cjvf usr.tar.bz2 usr/*\necho \"pack usr to usr.tar.bz2 ok\"\n```\n\n以上，在宿主机上的操作结束了。接下来是在开发板上的操作。\n\n##### 开发板上的操作\n\n​\t将打包好的`usr.tar.bz2`解压到开发板的根目录，并尝试执行`/usr/sbin/sshd`来启动ssh服务，可能会出现缺少动态链接库的情况，可以从宿主机上复制过来。其中`libcrypto`存在于openssl的源代码目录下面，`libz`存在于zlib的源代码目录中。`libcrypto`可直接复制到开发板的`/lib`目录下，而`libz`则需要建立软连接：`ln -s /lib/libz.so.1.2.11  /lib/libz.so.1`\n\n​\t然后进行如下配置\n\n> ssh的配置文件进行修改，以允许`root`登录：修改 `/usr/local/etc/ssh_config`，将`PermitRootLogin yes`前面的注释去掉，如果没有这句，就打进去吧。\n>\n> 修改`/etc/passwd`,增加以下三句\n>\n> > root: x :1000:1000:root:/root:/bin/sh\n> > root : x :0:Linux User,,,:/home/root:/bin/sh\n> >\n> > sshd: x :74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\n>\n> x旁边的两空格要删除掉，我这个编辑器会把他们显示为:x:..... 这两句话是为了修改`root`密码的时候出现`unknown uid 0`的情况\n>\n> 执行\n>\n> ```shell\n> mkdir /var/empty/sshd/etc -p\n> cd /var/empty/sshd/etc\n> ln -s /etc/localtime localtime\n> ```\n>\n> 防止出现`Missing privilege separation directory: /var/empty/`这个错误\n\n​\t好了，现在你可以对`root`密码进行修改，并启动ssh了。\n\n​\t为了可以开机启动ssh服务，需要在`/etc/init.d/rcS`的最后面加上`/usr/sbin/sshd &`\n\n​\t- wan\n\n","tags":["嵌入式","软件移植"]},{"title":"在Coding和Github上进行双线自动化部署Hexo","url":"/2020/02/21/在Coding和Github上进行双线自动化部署Hexo/","content":"\n### 起因\n\n​\t\t我前几天开始搭建这个博客，由于之前搭建过很多次，所以没有出现什么意外就搭建完了。但是当我把博客地址给其他人的时候，他们有的反应打得开，有的反应打不开。经过一番谷歌之后我发现原因可能是gitpage的服务器在国外，会出现加载失败的问题。与此同时我又了解到国内也有提供类似静态页面托管服务的厂家，我就想把博客也一并部署到国内的服务器上。我选择了可免费绑定域名的Coding（需要实名认证）。  \n\n​\t\t我这种经常宿舍实验室两头跑的人有在不同电脑上写博客的需求，而我又不想每次都要拷个源代码，于是便萌生了将博客源代码上传到github去的想法。但是这样一来每次写完代码都要做git三连和hexo三连，很是麻烦。一番搜索之后发现Appveyor可以实现自动化部署hexo，只需要推送到远程仓库，Appveyor就可以帮我自动部署了。\n\n​\t\t但是对于coding的话，我用Appveyor就找不到什么好方法了。我们可以利用github自带的Ci来进行Coding的静态页面的自动化部署。当然你也可以不用Appveyor，直接利用github的Ci进行部署也是可以的。\n\n### 要求\n\n\t\t- 一个域名\n\t\t- 一个github账户\n\t\t- 一个coding账户（需要实名认证）\n\n### 过程\n\n#### 1. 新建仓库\n\n​\t\t我们先新建一个公开的源码仓库，用于保存博客源代码。\n\n#### 2. 去Appveyor注册\n\n​\t\t[注册网址](https://ci.appveyor.com/signup)，选择**FREE-for open-source projects** ,并选择使用github账户登录。\n\n![image-20200223213407364](/../img/image-20200223213407364.png)\n\n#### 3. 新建并加密一个Access_Token\n\n​\t\t[申请地址](https://github.com/settings/tokens/new)，这是用来申请一个Token，Appveyor就是利用这个来访问你的Github仓库的，我把权限全部给了。在最上面的Note一栏里面填入这个Token的名字，随意。\n\n​\t\t\t\t![image-20200223213834567](/../img/image-20200223213834567.png)\n\n​\t\t然后点击最下面的Generate token。复制好他给出的Token，它只会出现一次，如果你忘记了的话，只能删掉重新生成一个了。\n\n![image-20200223213922721](/../img/image-20200223213922721.png)\n\n​\t\t因为这个仓库是公开的，而且这个Token是要放在这个仓库里面的，为了安全，我们需要对它进行加密。来到[Appveyor提供的加密页面](https://ci.appveyor.com/tools/encrypt)，输入刚才新建的Token，点击Encypt，即可生成加密后的Token。\n\n#### 4. 新建Appveyor的配置文件\n\n​\t\t在博客源代码目录中新建一个`appveyor.yml`，你可以根据官方文档自行填写，也可仿照我的：\n\n```yaml\nclone_depth: 5\n\nenvironment:\n  access_token:\n    secure: 填写你的加密后的Token\n\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\n\nbuild_script:\n  - hexo generate\n\nartifacts:\n  - path: public\n\non_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n\n```\n\n​\t\t其中`GIT_USER_EMAIL`,`GIT_USER_NAME`,`TARGET_BRANCH`,`STATIC_SITE_REPO`，他们分别是git的用邮箱、用户名、待部署仓库的目标分支，待部署的目标仓库（你的静态页面的github地址）。这几个都是要我们去Appveyor里面设置的环境变量。\n\n#### 5. Appveyor的配置\n\n​\t\t回到Appveyor，点击New Project\n\n![image-20200223214015897](/../img/image-20200223214015897.png)\n\n​\t\t选择github里面你的博客源代码目录，点击右侧的Add，在新页面选择setting\n\n![image-20200223214102188](/../img/image-20200223214102188.png)\n\n​\t\t选择Environment，添加第四点所说的的环境变量\n\n​\t\t![image-20200223215652016](/../img/image-20200223215652016.png)\n\n​\t\t点击Save保存好配置。\n\n​\t\t之后，你只要把你的博客源代码推送到远程仓库之后，Appveyor会自动检测到你的推送并进行自动化部署。类似这样：\n\n​\t\t![image-20200223220116830](/../img/image-20200223220116830.png)\n\n​\t\t\t并且可以再你的源代码仓库里面查看是否部署成功：\n\n![image-20200223220259404](/../img/image-20200223220259404.png)\t\n\n​\t\t\t\t\n\n#### 6. 对Coding进行自动部署\n\n​\t\t来到Coding的[官网](https://coding.net/)，点击个人版登录，新建一个DevOps项目，建议项目名称跟你的用户名一致。在右侧的“构建与部署”处选择静态网站，选择立即发布静态网站，网站名称随意。\n\n​\t\t然后进入到个人设置，点击访问令牌\n\n![image-20200223221358546](/../img/image-20200223221358546.png)\n\n​\t\t这个类似于github的Access_Token,在这里我也是把权限全给了。\n\n​\t\t创建完成后记住令牌和令牌用户名。回到github的博客源代码仓库，选择上方的Actions，这个也就是github的Ci，选择**Set up a workflow yourself** \n\n![image-20200223221848554](/../img/image-20200223221848554.png)\n\n​\t\t在出现的编辑窗口里面，用下面的文本替换掉里面的内容（知乎上的一个大佬的配置）\n\n```yaml\nname: 自动部署 Hexo\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps:\n      - name: 开始运行\n        uses: actions/checkout@v1\n\n      - name: 设置 Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: 安装 Hexo CI\n        run: |\n          export TZ='Asia/Shanghai'\n          npm install hexo-cli -g\n      - name: 缓存\n        uses: actions/cache@v1\n        id: cache-dependencies\n        with:\n          path: node_modules\n          key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}}\n\n      - name: 安装插件\n        if: steps.cache-dependencies.outputs.cache-hit != 'true'\n        run: |\n          npm install\n      - name: 部署博客\n        run: |\n          hexo clean && hexo g\n          cd ./public\n          git init\n          git config user.name \"${{secrets.GIT_NAME}}\"\n          git config user.email \"${{secrets.GIT_EMAIL}}\"\n          git add .\n          git commit -m \"Update\"\n          git push --force --quiet \"https://${{secrets.CD_TOKEN}}@${{secrets.CD_REF}}\" master:master\n```\n\n​\t\t其中，以`secrets.`开头的四个变量是需要我们去设置的环境变量。 点击右边的Start commit保存。\n\n​\t\t我们进入源码仓库的环境变量设置，其位置如下：\n\n​\t\t![image-20200223222546211](/../img/image-20200223222546211.png)\n\n​\t\t这四个变量的意思分别如下表所示：\n\n|   变量    |              意思               |\n| :-------: | :-----------------------------: |\n| GIT_NAME  |           git的用户名           |\n| GIT_EMAIL |            git的邮箱            |\n|  CD_REF   |   coding的静态页面的仓库地址    |\n| CD_TOKEN  | coding的令牌用户名:coding的令牌 |\n\n其中CD_REF在你的Coding的右上方可以看到，改成ssh之后@后面的就是CD_REF了。\n\n![image-20200223223844299](/../img/image-20200223223844299.png)\n\n以后我们每次写完文章，直接git三连就可以自动化部署到两个静态页面托管仓库了。\n\n#### 7. 域名绑定\n\n​\t\t我们可以对域名的dns解析记录进行修改，实现国内用户访问的是coding上的页面，国外用户访问github上的页面。\n\n​\t\t一图流：\n\n​\t\t![image-20200223225143011](/../img/image-20200223225143011.png)\n\n​\t\t\t如果你的coding站点无法申请到证书，请暂停下境外的解析。\n\n​\t\t-完","tags":["Hexo","没有用的知识","自动化部署"]},{"title":"基于4412的opencv的移植(附带contrib)","url":"/2020/02/20/基于4412的opencv的移植-附带contrib/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 18.04LTS 64位\n\n#### 使用的工具\n\n1. 2013版的交叉编译工具(arm-2013.05-24-arm-none-linux-gnueabi)\n2. opencv_3.4.9\n3. opencv_contrib_3.4.9\n4. cmake-gui\n\n#### 问题\n\n1. 放假之前用的虚拟机被我删除了，里面的文件都没了。\n2. 开发板的文件系统被我折腾坏了\n3. 需要重新移植opencv\n\n#### 解决过程：\n\n##### 1. 下载所需软件以及源代码\n\n​\t\t首先下载好我们需要使用到的各个文件，他们的下载链接如下所示：\n\n```\narm-2013.05-24-arm-none-linux-gnueabi\t\t链接：http://pan.baidu.com/s/1i3gNttF\nopencv_3.4.9\t链接：https://github.com/opencv/opencv/archive/3.4.9.tar.gz\nopencv_contrib_3.4.9 链接：https://github.com/opencv/opencv_contrib/archive/3.4.9.tar.gz\n```\n\n至于cmake-gui的话，如果你使用的是ububtu，直接在终端输入`sudo apt install cmake-gui`即可。\n\n将交叉编译器解压好，这里我的是`/home/gukki/baidunetdiskdownload/arm-2013.05/`\n\n将下载并解压好的两份源代码放在同一个目录。\n\n##### 2. 使用cmake-gui进行交叉编译\n\n​\t\t打开cmake，如下图所示：（只截取了上半部分）\n\n![image-20200220202805847](/../img/image-20200220202805847.png)\n\n​\t\t第一行是要求你输入你的opencv的源代码的绝对路径，在这里我的路径是`/home/gukki/OpenCv/Source_Code/opencv-3.4.9`，第二行要求你填写配置好的源代码的保存路径。在这里，我的是`/home/gukki/OpenCv/Process_Code`。\n\n​\t\t填写完毕之后点击`Configure`，cmake要求你选择编译工具，由于我们是交叉编译，我们选择最后一项。点击下一步之后如下图所示：\n\n![image-20200220203339941](/../img/image-20200220203339941.png)\n\n​\t\t其中`Operating System`顾名思义，操作系统，我们的开发板上用的是Linux，就写上吧。\n\n`C`要求你指定好交叉编译器的C编译器，也就是arm-gcc的所在地。\n\n`C++`同理，也是要求你填上arm-g++的所在地，而`Target Root`填写上你交叉编译器的目录。\n\n​\t\t填写完成之后点击完成。\n\n​\t\t配置完成之后应该会是一片红色，并且左下角的文本显示区域有一句`Configuring done`。\n\n我们对我们的需求进行对opencv的裁剪：\n\n> 在搜索栏区域输入JPEG,勾选上`BUILD_JPEG`  \n>\n> 输入PNG,勾选上`BULID_PNG`\n>\n> 输入nonfree，勾选上\n>\n> 输入gtk，取消勾选，因为我们用不上图形界面\n>\n> 输入zlib，勾选上\n>\n> 输入extra，在`Value`一栏上点击右边的三个点，定位好你的`opencv_contrib`的`moudules`文件夹。\n>\n> 输入prefix，输入你想安装到的文件夹路径。等会`make install`时会安装到这里。    \n\n​\t\t配置完成之后点击`Configure`，此时你应该要下载一些有关附加模块的一些文件，可能需要很久，等不及的就不去配置extra。下载完成之后，可以再次对额外模块进行裁剪，根据你的需求来定。裁剪完成之后，再次点击`Configure`，应该不会出现红色了。\n\n点击`Generate`生成工程文件。  \n\n##### 3.编译文件\n\n​\t\t进入你的配置好的源代码的文件夹，在此处打开终端，输入`make`开始编译，根据自身虚拟机配置情况，可在后面加上`-j线程数`这个参数，我给虚拟机分配了8个核心，所以我编译速度比较快，只用了5分钟左右。如果你什么都没加，预计时间可能是半小时到一小时左右。中间可能有些警告，无须理会。只要没停下来就好。\n\n![image-20200220210124846](/../img/image-20200220210124846.png)\n\n可以看到处理器是被吃满的。  \n\n​\t\t编译完成后输入`make install`，可能需要你加个`sudo`什么的....\n\n​\t\t安装完成之后可以去设定的`prefix`文件夹去看看。应该长这样：\n\n![image-20200220210712344](/../img/image-20200220210712344.png)\n\n​\t\t其中`lib`里面是我们编译好的库文件，使用`file`命令查看类型：\n\n![image-20200220210841342](/../img/image-20200220210841342.png)\n\n​\t\t成功了大半了！\n\n##### 4. 移植到开发板上\n\n​\t\t将`lib`文件夹里面的所有文件全部传到开发板的`/lib`，目录下面，使用`nfs`速度会快很多。\n\n​\t\t由于我们使用了较新版本的`arm_gcc`编译工具链，我们还需要把交叉编译工具链里面的`libstdc++.so,libstdc++.so.6,libstdc++6.0.17`一起复制过去并覆盖。他们位于`arm-2013.05/arm-none-linux-gnueabi/libc/usr/lib/`这个地方。\n\n##### 5. 虚拟机编译设置\n\n​\t\t为了让虚拟机知道opecv的头文件和库文件的位置，我们需要借助一个叫做`pkg-config` 的软件， 安装也是可以用`apt`来安装的。我们找到opencv库文件夹里面的pkgconfig文件夹，打开你的shell的配置文件，我使用的是`zsh`所以打开`.zshrc`加入以下的两句话句话：\n\n```\nPKG_CONFIG_PATH=/home/gukki/OpenCv/_Install/lib/pkgconfig/:$PKG_CONFIG_PATH\nexport PKG_CONFIG_PATH\n```\n\n​\t\t自行替换你的pkgconfig文件夹位置。\n\n​\t\t使用`source`命令让更改生效，输入`pkg-config --cflags --libs opencv`，应该会出现一大坨东西，如下所示：\n\n![image-20200220212101215](/../img/image-20200220212101215.png)\n\n##### 6. 测试与简化\n\n​\t\t写一个非常简单的程序，来测试下吧：\n\n```c++\n#include<opencv2/opencv.hpp>\nusing namespace cv;\nint main()\n{\n  Mat m;\n  return 0;\n}\n```\n\n​\t\t保存为`T.cpp`，使用如下命令进行编译：\n\n```shell\narm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` T.cpp -lpthread -lrt -ldl \n```\n\n​\t\t应该只有一个警告，不需要理会。\n\n​\t\t生成的`a.out`文件拷贝到开发板，给予权限。运行之后应该什么效果都没有，也没有任何报错。那就是行了。你可以试试更加复杂的程序了。但是不能有任何跟界面有关的函数出现比如`imshow`，`waitkey`等等，否则会报错。（因为我裁剪掉了）你也可以自行尝试如何让他们使用，有更好的想法可以告诉我！\n\n​\t\t每次编译都要打那么长的代码，有没有方法可以简化？\n\n​\t\t可以使用`alias`命令来进行简化，我的就是：\n\n```shell\nalias armcv=\"arm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` -lpthread -ldl -lrt\"\n```\n\n​\t\t同样的，写到你自己的shell的配置文件里面。\n\n​\t\t完-\n\n​\t\t","tags":["嵌入式","软件移植"]},{"title":"4412的wifi驱动以及管理软件的移植","url":"/2020/02/20/4412的wifi驱动以及管理软件的移植/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位  \n\n#### 问题\n\n1. 给的pdf上面的wifi模块的型号不对\n\n   > 它给我的是**rt8723bu**这个型号的驱动，实际上开发板上搭载的是![image-20200219235946818](/../img/image-20200219235946818.png)\n   >\n   > 这个型号的驱动\n\n2. 由于缺少`wpa_supplicant`这个管理软件，wifi无法连接到加密的网络\n\n     \n\n   \n\n #### 解决过程\n\n​\t\t我仔细地查看开发板，发现开发板搭载的是`rtl8188eus`这个型号的无线模块。知道是什么型号的就好办了，直接开始移植吧。\n\n​\t\t我先从google上找到了驱动源代码的[github](https://github.com/quickreflex/rtl8188eus)，clone下载之后，先对`Makefile`进行修改，由于它默认是i386平台，我们需要先对它进行屏蔽，并加入我们的设备。如下图所示：\n\n![image-20200220001655792](/../img/image-20200220001655792.png)\n\n![image-20200220001636696](/../img/image-20200220001636696.png)\n\n其中`CONFIG_PLATFORM_ARM_Exynos4412=y`是我们新添加的设备。\n\n​\t\t在1690行附近加入一段判断语句：\n\n```shell\nifeq ($(CONFIG_PLATFORM_ARM_Exynos4412), y)                                   \nEXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN                                  \n ARCH := arm                                                 \nCROSS_COMPILE := arm-none-linux-gnueabi-                                  \nKVER:=3.5.0                                                 \nKSRC :=/home/gukki/HostFiles/A9/SRC/kernel/linux-3.5.0-rc6/                         \nMODULE_NAME :=wlan                                             \nendif\n```\n\n​\t\t注意`KVER`是你的内核版本号，`KSRC`是你的交叉编译好的内核目录。\n\n​\t\t保存退出之后，直接`make`即可。生成的`wlan.ko`可通过minicom进行传输到开发板上，开发板上使用`insmod wlan.ko`来安装驱动。\n\n​\t\t驱动安装完成之后使用`ifconfig -a`来进行查看自己的无线网卡的名字，并且使用`ifconfig 无线网卡名字 up`来进行启用网卡。\n\n​\t\t驱动完成安装之后，运行`iwconfig`应该如下所示：\n\n![image-20200220011149442](/../img/image-20200220011149442.png)\n\n-----------------------------------------------------------------------------------------------------------------------------------\n\n​\t\t驱动安装完成之后，我发现这模块只能连接开放的wifi，进过一番google之后发现，我还需要移植一个名为[**wpa_supplicant**](https://w1.fi/releases/wpa_supplicant-0.7.2.tar.gz)   的软件来进行管理。而这个软件又依赖于[**openssl**](https://ftp.openssl.org/source/old/0.9.x/openssl-0.9.8e.tar.gz)这个库，索性一次全部搞定吧。\n\n​\t\t这里我的wpa版本是0.7.2,ssl版本是0.9.8.e。先从网上把他们下载下来。我将他们都解压到一个文件夹里。openssl的移植需要wpa提供的补丁文件。\n\n​\t\t执行命令:\n\n​\t\t\t`cp wpa_supplicant-0.7.2/patches/openssl-0.9.8e-tls-extensions.patch ./openssl-0.9.8e`\n\n​\t\t\t`cd openssl-0.9.8e`\n\n​\t\t\t` patch -p1 < openssl-0.9.8e-tls-extensions.patch`\n\n​\t\t创建一个干净的文件夹，我的路径是`/home/gukki/Cross_Code/Cross/openssl/`，在openssl-0.9.8目录里面运行`Configure`脚本来进行配置`Makefile`：\n\n```shell\n\t\t./Configure linux-elf-arm -DL_EDNIAN linux:'arm-none-linux-gnueabi-gcc' shared --prefix=/home/gukki/Cross_Code/Cross/openssl/ -lcrypto\n```\n\n​\t\t配置完成之后就可以`make && make install`了。生成的动态库文件在openssl/lib里面。  \n\n​\t\t接下来进行wpa的移植。  \n\n​\t\t进入wpa的源代码目录，修改`Makefile`文件，注释掉第一和第三行，并将CC改为你的交叉编译器，\n\n在\n  `  CFLAGS += -I../src`\n  `  CFLAGS += -I../src/utils `\n    下添加：\n  `  CFLAGS += -I/home/gukki/Cross_Code/Cross/openssl/include/`\n\n修改\n   ` LIBS += -lssl`\n    为\n    `LIBS += -lssl -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n修改\n   `LIBS_p += -lcrypto`\n    为\n `   LIBS_p += -lcrypto -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n​\t\t保存并退出，将目录下面的`defconfig`复制为`.config`并执行`make`\n\n​\t\t编译完成之后，将目录下面的`wpa_supplicant`和`wpa_cli`文件拷贝到开发板的`/bin`目录下面。\n\n------------------\n\n​\t\t为了连接上加密的wifi，还需要在开发板的`/etc`目录下面添加wpa-psk-tkip.conf这一配置文件。\n\n我的配置文件如下所示：\n\n```\n WPA-PSK/TKIP\n        ctrl_interface=/var/run/wpa_supplicant\n        network={\n        ssid=\"****\"\n        key_mgmt=WPA-PSK\n        proto=WPA RSN\n        pairwise=CCMP\n        group=CCMP\n        psk=\"***\"\n        }\n\n```\n\n​\t\t其中ssid是你的wifi名字，psk是你的密码。\n\n​\t\t在开发板内创建wpa程序的运行目录：`mkdir /var/run/wpa_supplicant -p`\n\n​\t\t平时使用`wpa_supplicant -B -i wlan0 -c /etc/wpa-psk-tkip.conf`即可连接到wifi。\n\n​\t\t连接到之后需要自己更改ip地址和默认网关。具体操作请自行搜索。","tags":["嵌入式","驱动移植","软件移植"]}]