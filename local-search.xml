<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>39 组合总和</title>
    <link href="/p/5cce.html"/>
    <url>/p/5cce.html</url>
    
    <content type="html"><![CDATA[<p>一道利用DFS解决的组合问题</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：candidates = [2,3,6,7], target = 7,<br />所求解集为：<br />[<br />[7],<br />[2,2,3]<br />]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：candidates = [2,3,5], target = 8,<br />所求解集为：<br />[<br />[2,2,2,2],<br />[2,3,3],<br />[3,5]<br />]</p></blockquote><p><strong>提示：</strong></p><p>1 &lt;= <code>candidates.length</code> &lt;= 30<br />1 &lt;= <code>candidates[i]</code> &lt;= 200<br /><code>candidate</code> 中的每个元素都是<strong>独一无二</strong>的。<br />1 &lt;= <code>target</code> &lt;= 500</p><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​先说第一眼感觉，我觉得要先排序，然后一个一个数字地去取。但是具体的实现细节就想不出来了。哎，不知道是比别人笨还是经验不够丰富怎么的。</p><p>​稍加思索可以写出个伪代码框架出来：</p><div class="hljs"><pre><code class="hljs crystal"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span></span>(target,list)&#123;<span class="hljs-keyword">for</span> num in <span class="hljs-symbol">candidates:</span>list.add(num);dfs(...)&#125;</code></pre></div><p>​对于一个递归而言，缺了点终止条件。那么什么时候该停止呢？</p><p>​根据<strong>三数之和</strong>的经验，以及题解区大佬的讲解，每次给递归调用传递的<code>target</code>可转变为<code>当前target-当前选择的数字</code>，即：</p><div class="hljs"><pre><code class="hljs crystal"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span></span>(target,list)&#123;...list.add(num);dfs(target-num,list);&#125;</code></pre></div><p>​显而易见的，递归停止条件为：</p><ul><li><p>传入的<code>target</code>小于<code>0</code>（你选择的数字组合加起来比目标值还要大了）</p></li><li><p>传入的<code>tartget</code>等于0（你选择的数字组合刚刚好等于目标值）</p><p>所以伪代码可以改成：</p></li></ul><div class="hljs"><pre><code class="hljs cmake">fun dfs(<span class="hljs-keyword">target</span>,<span class="hljs-keyword">list</span>)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span>&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span>==<span class="hljs-number">0</span>)res.add(array)<span class="hljs-keyword">else</span>&#123;for num in candidates:<span class="hljs-keyword">list</span>.add(num);dfs(<span class="hljs-keyword">target</span>-num,<span class="hljs-keyword">list</span>);&#125;&#125;</code></pre></div><p>​初具规模了，但是对于DFS而言，做出选择之后，还要有一手撤销选择。在这里，做出选择就是<code>list.add(num)</code>（选择了这个数字），递归结束的时候，不管成还是不成，我们都要把<code>dfs(target-num,list)</code>所造成的影响去除掉，所以需要在调用递归之后，删除掉调用递归时候增加的数字，也就是最后一个数字：</p><div class="hljs"><pre><code class="hljs cmake">fun dfs(<span class="hljs-keyword">target</span>,<span class="hljs-keyword">list</span>)&#123;...dfs(<span class="hljs-keyword">target</span>-num,<span class="hljs-keyword">list</span>);<span class="hljs-keyword">list</span>.<span class="hljs-keyword">remove</span>(lastnum);&#125;</code></pre></div><p>​再有，看看题目，题目要求的是组合，跟我之前学的<strong>排列</strong> 是不一样的，对于<strong>示例一</strong>，<code>[2,2,3]</code>和<code>[2,3,2]</code>、<code>[3,2,2]</code>是一个答案。因为他们是组合，只要求他们的和为<code>7</code>就行，顺序无所谓。</p><p>​但是我们的伪代码会出现重复，因为每次递归都是从头开始，又因为上面说的<code>[2,2,3]</code>和<code>[2,3,2]</code>、<code>[3,2,2]</code>是没有任何区别的，所以我们需要传入一个参数<code>index</code>，表示当前的位置，又因为可以重复取数字，所以递归开始时的数组索引应该就是<code>index</code>。</p><div class="hljs"><pre><code class="hljs sas">fun dfs(target,<span class="hljs-meta">list</span>,<span class="hljs-meta">index</span>)&#123;<span class="hljs-meta">if</span>(target&lt;0)<span class="hljs-meta">return</span>;<span class="hljs-meta">if</span>(target==0)res.<span class="hljs-meta">add</span>(<span class="hljs-meta">array</span>)<span class="hljs-meta">else</span>&#123;for i=<span class="hljs-meta">index</span>,i&lt;candidates.<span class="hljs-meta">length</span>,i++<span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(cadidates[i]);dfs(target-cadidates[i],<span class="hljs-meta">list</span>,i);<span class="hljs-meta">list</span>.<span class="hljs-meta">remove</span>(lastnum);&#125;&#125;</code></pre></div><p>​为什么传入一个<code>index</code>就可以去除重复呢，<code>index</code>之前的数字我们都已经穷举完了，比如对于<code>[2,2,...]</code>我们已经把<code>...</code>的所有可能结果都穷举完了，包括<code>[2,2,3]</code>，所以在<code>[2,3,...]</code>没必要再回头穷举<code>3</code>之前的东西了，因为我们已经把有第二个<code>2</code>的情况穷举完了。</p><p>​借用题解大佬的一句话：</p><blockquote><p>排列与组合的<code>dfs</code>函数实现上最大的区别是什么呢，就是：排列的for循环每次从头开始，而组合的for循环每次从当前元素开始：</p><p><code>for(int i=0;i&lt;n;i++){//求排列</code></p><p><code>for(int i=start;i&lt;n;i++){//求组合</code><br />这里最后的结果集有重复正是因为相同元素的排列顺序不同，那就用求组合的办法就好了嘛</p><p>然后因为元素使用次数无限，所以<code>candidates[i]</code>还可以再被使用，所以下一层递归也是从当前元素开始：</p></blockquote><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        Arrays.sort(candidates);        dfs(<span class="hljs-number">0</span>,candidates,target, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> target,List&lt;Integer&gt; list)</span></span>&#123;        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)   lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(list));        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; array.length &amp;&amp; target&gt;=array[i]; i++) &#123;                list.add(array[i]);                dfs(i,array,target-array[i],list);                list.remove(list.size()-<span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1007 行相等的最少多米诺旋转</title>
    <link href="/p/34f.html"/>
    <url>/p/34f.html</url>
    
    <content type="html"><![CDATA[<p>这我真没看出哪里有贪心了…</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>在一排多米诺骨牌中，<code>A[i]</code> 和 <code>B[i]</code> 分别代表第 <code>i</code> 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 <code>1</code> 到 <code>6</code> 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）</p><p>我们可以旋转第 <code>i</code> 张多米诺，使得 <code>A[i]</code> 和 <code>B[i]</code> 的值交换。</p><p>返回能使 <code>A</code> 中所有值或者 <code>B</code> 中所有值都相同的最小旋转次数。</p><p>如果无法做到，返回 <code>-1</code>.</p><p><strong>示例 1：</strong></p><p><img src="/img/%601007-%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC%60/domino.png" srcset="/img/loading.gif" alt="img" /></p><blockquote><p><strong>输入：</strong> A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]<br /><strong>输出：</strong> 2<br /><strong>解释：</strong><br />图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。<br />如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。<br />示例 2：</p></blockquote><blockquote><p><strong>输入：</strong>  A = [3,5,1,2,3], B = [3,6,3,3,4]<br /><strong>输出：</strong>  -1<br /><strong>解释：</strong><br />在这种情况下，不可能旋转多米诺牌使一行的值相等。</p></blockquote><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​第一想法是找到出现次数最多的数字<code>max</code>，再逐一翻转为<code>max</code>。若有一列不能做到，返回<code>-1</code></p><p>​其实还可以这样想：</p><p>​如果给的多米诺数组是可以成功旋转的，那么目标数字必定会出现在所有的列中，对于<strong>示例1</strong>，可以观察得到，目标数字<code>2</code>出现在了每一列中。</p><p>​我们不妨指定一列，比如<code>A[0]，B[0]</code>。我们尝试将数组<code>A</code>中的所有数字旋转成<code>A[0]</code>，前提条件是数组<code>B</code>对应位置是<code>A[0]</code>（要想把当前数字改变成A[0]，必须要有对应的数字可供旋转），或者说数组<code>A</code>当前位置的数字就是<code>A[0]</code>（不用旋转）。记录旋转次数<code>r_A</code>。</p><p>​然后尝试将数组<code>B</code>中的所有数字旋转成<code>A[0]</code>，过程同理，记录旋转次数<code>r_A</code>，然后返回两个旋转次数的最小值<code>min</code>。如果两个操作都执行不了，就返回<code>-1</code></p><p>​上面两个操作都是尝试将两个数组都转换为<code>A[0]</code>，如果操作成功，就直接返回<code>min</code>，操作无法完成的话，就尝试将两个数组转换为<code>B[0]</code>。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDominoRotations</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = A.length;        <span class="hljs-keyword">int</span> res = check(A[<span class="hljs-number">0</span>],A,B,len);<span class="hljs-comment">//尝试将俩个数组的值旋转为A[0]</span>        <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//操作成功，返回最小值</span>        <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> check(B[<span class="hljs-number">0</span>],A,B,len);<span class="hljs-comment">//否则执行将两个数组的值转换为B[0]</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">int</span> r_A = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> r_B = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span>(A[i]!=target&amp;&amp;B[i]!=target)  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果这一列并不包含目标数字，肯定是失败的。</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[i]!=target)   r_A++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(B[i]!=target)   r_B++;        &#125;        <span class="hljs-keyword">return</span> Math.min(r_A, r_B);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>129 求根到叶子节点数字之和</title>
    <link href="/p/11f9.html"/>
    <url>/p/11f9.html</url>
    
    <content type="html"><![CDATA[<p>很典型的广度优先搜索和深度优先搜索的二叉树的题目</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个二叉树，它的每个结点都存放一个 <strong>0-9</strong> 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3]<br />1<br />/ \<br />2   3<br /><strong>输出:</strong> 25<br /><strong>解释:</strong><br />从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>.<br />从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>.<br />因此，数字总和 = <code>12 + 13 = 25</code>.</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入</strong>: [4,9,0,5,1]<br />4<br />/ \<br />9   0<br />/ \<br />5   1<br /><strong>输出</strong>: 1026<br /><strong>解释:</strong><br />从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 <code>495</code>.<br />从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 <code>491</code>.<br />从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 <code>40</code>.<br />因此，数字总和 = <code>495 + 491 + 40 = 1026</code>.</p></blockquote><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​这题一看，就知道是用<code>DFS</code>，但是我因为之前学的东西，框架思维挺严重的，老是想着每次遍历不会出现重复，怎么撤销操作什么的。其实不用那么麻烦，我们把二叉树分为<strong>左子树</strong>和<strong>右子树</strong>，每个子树都是一梭子下去。</p><p>​比如，对于<strong>示例2</strong>，我们把它先分成左、右两个子树，左子树是<code>[4-&gt;9-&gt;5、1]</code>，右子树是<code>[4-&gt;0]</code>。</p><p>​先遍历左子树：<code>[4、9]</code>，此时出现了一个分叉路，还是一样的，选择左边的：<code>[4、9、5]</code>，到头了。倒回刚才的分叉路，选择右边的：<code>[4、9、1]</code>到头了，退回去，选择右边的<code>[4、0]</code>。</p><p>​那么我们怎么知道当前我当前位置代表了什么数字呢？可以把之前得到的和<strong>乘与</strong><code>10</code>再加上<strong>当前</strong>节点的值作为当前节点<strong>新</strong>的值。比如，对于<strong>示例2</strong>，根节点不理它，到第二层节点，左边的节点<code>9</code>保存的新值应该就是<code>4*10+9=49</code>，到了第三层的左边节点<code>5</code>，可以按照之前的样子，保存为<code>49*10+5=495</code>。我们可以维护一个值<code>res</code>保存各个叶节点之和，<code>res</code>就是我们要返回的值。</p><hr /><p>​还可以使用<code>BFS</code>，我觉得这个比<code>DFS</code>好理解。维护一个变量<code>sum</code>，用于保存叶节点的和。我们使用一个队列，保存当前节点的左右节点。</p><p>​当队列不为空时，弹出一个节点，判断是否是叶节点，若为叶节点，<code>sum+=叶节点.值</code>；</p><p>​不是叶节点的话，修改它的左右子节点的值为<code>当前节点.值*10+子节点.值</code>，比如<strong>当前节点</strong>值为<code>47</code>，它的<strong>左子节点</strong>值为<code>3</code>，那么修改左子节点的值为<code>47*10+3</code>。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h1><p><code>DFS</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> dfs(root,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        res = res * <span class="hljs-number">10</span> + root.val;<span class="hljs-comment">//保存当前位置的和</span>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果是叶节点，返回当前值。</span>            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">return</span> dfs(root.left,sum)+dfs(root.right,sum);<span class="hljs-comment">//继续遍历当前节点的左右子树，并将它们的叶子节点和加起来。</span>    &#125;</code></pre></div><p><code>BFS</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(root);<span class="hljs-comment">//初始化队列</span>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            TreeNode cur = queue.poll();<span class="hljs-comment">//弹出一个节点</span>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-keyword">null</span> &amp;&amp; cur.right == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//判断是否是叶节点</span>                res += cur.val;<span class="hljs-comment">//将当前叶节点的值加入结果</span>            &#125;            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//判断有无左子节点</span>                cur.left.val = cur.val * <span class="hljs-number">10</span> + cur.left.val;<span class="hljs-comment">//将左子节点的值更新为当前值加上子节点的值</span>                queue.offer(cur.left);<span class="hljs-comment">//将左子节点进队列</span>            &#125;            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//同理判断右节点</span>                cur.right.val = cur.val * <span class="hljs-number">10</span> + cur.right.val;                queue.offer(cur.right);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.05 一次编辑</title>
    <link href="/p/26a9.html"/>
    <url>/p/26a9.html</url>
    
    <content type="html"><![CDATA[<p>一道分情况讨论的题目</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p><p><strong>示例 1:</strong></p><blockquote><p>输入:<br />first = “pale”<br />second = “ple”<br />输出: True</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入:<br />first = “pales”<br />second = “pal”<br />输出: False</p></blockquote><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​我们可以从这两个字符串的长度来入手：</p><p>​首先，题目要求只能<strong>编辑一次</strong>或者<strong>零次</strong>，而且一次只能动<strong>一个</strong>字符，也就是说如果两个字符串长度相差大于<code>1</code>，</p><p>那么我们不用进行处理了，直接返回<code>false</code>便是。</p><p>​然后，在相差值为<code>1</code>的时候，有两种情况：<code>first</code>比<code>second</code>短，也就是<code>second</code><strong>增加了一个</strong>字符，那我们只需要逐字比对，跳过<code>second</code>里面不一样的字符，记录不一样字符的个数(<code>cot</code>)，然后根据<code>cot</code>是否为<code>1</code>，来判断是不是只需要编辑一次；第二种情况也是差不多了，<code>first</code>比<code>second</code>长，也是逐字比对，跳过<code>first</code>里面不一样的字符，记录不同数量。</p><p>​还有，相差值为<code>0</code>的时候，要想从<code>first</code>转换为<code>second</code>，只能通过<strong>替换</strong>字符来做到，所以也是逐字比对，但是不跳过不同的，记录不同字符的数量。根据不同数量是否为<code>1</code>来决定返回什么结果。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">oneEditAway</span><span class="hljs-params">(String first, String second)</span> </span>&#123;        <span class="hljs-keyword">int</span> len_1 = first.length();        <span class="hljs-keyword">int</span> len_2 = second.length();        <span class="hljs-keyword">if</span> (Math.abs(len_1 - len_2) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> ((len_1 == <span class="hljs-number">0</span> &amp;&amp; len_2 == <span class="hljs-number">1</span>) || (len_1 == <span class="hljs-number">1</span> &amp;&amp; len_2 == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//特殊情况</span>        <span class="hljs-keyword">if</span> (len_1 &gt; len_2) &#123;<span class="hljs-comment">//删除</span>            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> cot = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len_1 &amp;&amp; index &lt; len_2; i++) &#123;                <span class="hljs-keyword">if</span> (first.charAt(i) != second.charAt(index)) &#123;                    cot++;                    <span class="hljs-keyword">continue</span>;                &#125;                index++;            &#125;            <span class="hljs-keyword">if</span> (cot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len_1 &lt; len_2) &#123;<span class="hljs-comment">//插入</span>            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> cot = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len_2 &amp;&amp; index &lt; len_1; i++) &#123;                <span class="hljs-keyword">if</span> (second.charAt(i) != first.charAt(index)) &#123;                    cot++;                    <span class="hljs-keyword">continue</span>;                &#125;                index++;            &#125;            <span class="hljs-keyword">if</span> (cot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//替换</span>            <span class="hljs-keyword">int</span> cot = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len_1; i++) &#123;                <span class="hljs-keyword">if</span> (second.charAt(i) != first.charAt(i)) cot++;            &#125;            <span class="hljs-keyword">if</span> (cot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1191. K 次串联后最大子数组之和</title>
    <link href="/p/897c.html"/>
    <url>/p/897c.html</url>
    
    <content type="html"><![CDATA[<p>一道最大子数组之和的变种</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p><p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p><blockquote><p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p></blockquote><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p><p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod） 10^9 + 7</strong> 后再返回。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：arr = [1,2], k = 3<br />输出：9</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：arr = [1,-2,1], k = 5<br />输出：2</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：arr = [-1,-2], k = 7<br />输出：0</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= <code>arr.length</code> &lt;= 10^5</li><li>1 &lt;= <code>k</code> &lt;= 10^5</li><li>-10^4 &lt;= <code>arr[i]</code> &lt;= 10^4</li></ul><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​</p><p>​先明白一个概念：<strong>子数组</strong>是连续的，咱经验不够丰富在这上面纠结了半天。</p><p>​一开始我以为也是用动态规划来写，第一个测试用例倒是通过了，其他的…</p><p>​后来看一个大佬的<a href="https://leetcode.jp/leetcode-1191-k-concatenation-maximum-sum-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">写法</a>，感觉他讲的非常好，我尝试用自己的话复述一遍：</p><blockquote><p>这道题意思就是要我们找出一个连续子区间，并计算出他们的和。</p><p>那么，这个区间会出现在哪里呢？</p><ol><li>单独数组的中间部分</li><li>数组头和数组尾</li><li>数组尾+（K-2）*数组和+数组头</li></ol><p>为啥呢？可以看看下面的例子</p></blockquote><h2 id="第一种情况"><a class="markdownIt-Anchor" href="#第一种情况"></a> 第一种情况：</h2><p>设<code>arr[5] = {-1000,2,3,4,-9956}</code>，很容易就能看出他们的最大连续子区间就是中间那几个，我们把它重复几次：</p><p><code>{-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956}</code></p><p>可以很容易看出，无论重复多少次，最大连续子区间都是<code>{2,3,4}</code>，他们的和是<code>9</code></p><h2 id="第二种情况"><a class="markdownIt-Anchor" href="#第二种情况"></a> 第二种情况：</h2><p>一样的，设<code>arr[5]={7，8，5，-999，6}</code>，将它重复几次：</p><p><code>{7，8，5，-999，6,7，8，5，-999，6,7，8，5，-999，6,7，8，5，-999，6}</code></p><p>无论重复多少次，它的最大连续子区间都是<code>{6,7,8,5}</code>即数组尾和数组头。他们的和是<code>26</code></p><h2 id="第三种情况"><a class="markdownIt-Anchor" href="#第三种情况"></a> 第三种情况：</h2><p>设<code>arr[5]={-8,56,3,1,23}</code>,将它重复<strong>5</strong>次（以<code>|</code>作为分隔符，便于我的理解）：</p><p><code>{-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23}</code></p><p>仔细看看并思考，如果求<strong>最大</strong>的子数组的话，那我是不是应该从第一个数组的<code>{56,3,1,23}</code>开始加，加上中间**3（5-2）**个数组的和，再加上最后一个数组的<code>{-8,56,3,1,23}</code>，使得子数组之和最大。</p><p>其中第一个数组的<code>{56,3,1,23}</code>这一部分叫做数组尾，中间三个数组之和可以为<code>(K-2)*Σ(arr)</code>，加上最后一个数组的数组头。其中，数组头可以是整个数组，数组尾也同理。</p><p>综上所述，我们可以求出上面三种情况的最大值，并选择其中最大的返回即可。且易得<code>K</code>等于<code>1</code>的时候，只需要考虑第一种情况就够了。因为剩下两种都是需要重复（即<code>K&gt;=2</code>）才行。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">long</span> prefix = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前数组前缀和</span>        <span class="hljs-keyword">long</span> max_prefix = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大前缀和</span>        <span class="hljs-keyword">long</span> suffix = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前数组后缀和</span>        <span class="hljs-keyword">long</span> max_suffix = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大后缀和</span>        <span class="hljs-keyword">long</span> midSum = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前数组中间值的和</span>        <span class="hljs-keyword">long</span> max_midSum = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大中间和</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mod = (<span class="hljs-keyword">int</span>) (Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            prefix += arr[i];            max_prefix = Math.max(prefix, max_prefix);            suffix += arr[arr.length - <span class="hljs-number">1</span> - i];            max_suffix = Math.max(suffix, max_suffix);            <span class="hljs-keyword">if</span> (midSum &lt; <span class="hljs-number">0</span>) midSum = arr[i];<span class="hljs-comment">//如果中间值的和小于0，加上当前的数肯定是比当前数更小了，所以换成当前的数。</span>            <span class="hljs-keyword">else</span> midSum += arr[i];<span class="hljs-comment">//累加</span>            max_midSum = Math.max(max_midSum, midSum);        &#125;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (max_midSum % mod);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> case1 = (<span class="hljs-keyword">int</span>) (max_midSum % mod);            <span class="hljs-keyword">int</span> case2 = (<span class="hljs-keyword">int</span>) ((max_prefix + max_suffix) % mod);            <span class="hljs-keyword">int</span> case3 = (<span class="hljs-keyword">int</span>) ((max_prefix + max_suffix + prefix * (k - <span class="hljs-number">2</span>)) % mod);<span class="hljs-comment">//为啥数组和是用前缀和来表示呢？因为你看上面的循环，prefix会一直累加直到数组末尾，所以他可以等同于数组和。</span>            <span class="hljs-keyword">return</span> Math.max(Math.max(case1,case2),case3);        &#125;    &#125;&#125;</code></pre></div><p>​</p><p>需要注意的是，每个和都需要是长整型，不然容易计算出错。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>494. 目标和</title>
    <link href="/p/9c78cf30.html"/>
    <url>/p/9c78cf30.html</url>
    
    <content type="html"><![CDATA[<p>与动态规划作斗争-其二</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个<strong>非负整数</strong>数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例：</strong></p><p><strong>输入：</strong><code>nums: [1, 1, 1, 1, 1], S: 3</code><br /><strong>输出：</strong><code>5</code><br /><strong>解释：</strong></p><blockquote><p>-1+1+1+1+1 = 3<br />+1-1+1+1+1 = 3<br />+1+1-1+1+1 = 3<br />+1+1+1-1+1 = 3<br />+1+1+1+1-1 = 3</p></blockquote><p>一共有5种方法让最终目标和为3。</p><p><strong>提示：</strong></p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​一开始我就想着是不是用深度优先搜索或者动态规划来做，我看了看题解，发现大部分人说会超时，最后还是用动态规划来做了。</p><p>​参考评论区的大佬的说法：一般地，问题如果是从一个数组里面选择一些数字来组合成一个数，就可以化解成<strong>0-1背包问题</strong>。</p><p>这道题题目可以转化为：找到给定数组的一个正子集和负子集，使其的和为<code>target</code></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>设P为正子集，N为负子集，U为整个数组。有：</mtext><mspace linebreak="newline"></mspace><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><mo>−</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mspace linebreak="newline"></mspace><mtext>两边同时加上</mtext><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><mo>−</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mspace linebreak="newline"></mspace><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><mo>−</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><mspace linebreak="newline"></mspace><mtext>即</mtext><mspace linebreak="newline"></mspace><mn>2</mn><mo>⋅</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{设P为正子集，N为负子集，U为整个数组。有：}\\\Sigma{(P)}-\Sigma{(N)}=Target\\\text{两边同时加上}\Sigma{(P)}-\Sigma{(N)}:\\\Sigma{(P)}+\Sigma{(P)}-\Sigma{(N)}+\Sigma{(N)} = Target+\Sigma{(U)}\\\text{即}\\2\cdot\Sigma{(P)}=Target+\Sigma{(U)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">设</span><span class="mord">P</span><span class="mord cjk_fallback">为正子集，</span><span class="mord">N</span><span class="mord cjk_fallback">为负子集，</span><span class="mord">U</span><span class="mord cjk_fallback">为整个数组。有：</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">两边同时加上</span></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">即</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span></span></span></p><p>​就是说在给定的数组里面找到一些数，他们的和的两倍是目标数字加上整个数组之和。换言之，如果目标数字加上整个数组之和不是个偶数，那么就肯定不存在这个正子集。这是一个判断条件。</p><p>​那么按照动态规划的思路：</p><blockquote><ul><li>定状态</li><li>找基态</li><li>写转移方程</li></ul></blockquote><p>​我们一步一步来，先是定状态，前面我们已经讲过，这道题可以转换为背包问题来解决。一样的，我们的状态可以为<strong>选取数的范围</strong>（物品）以及<strong>要凑成的数</strong>（重量）这两种。很容易的，我们可以用一个二维数组<code>dp[i][j]</code>来表示对于索引<code>[0,i]</code>的数，我们能凑出<code>j</code>的方法数量。</p><p>​状态我们明确了，那么就来找找最基础的状态了，根据背包问题的经验，<code>dp[0][0]</code>的方法数量始终为<code>1</code>，因为选择前<code>0</code>个数的时候，合成<code>0</code>的方法永远都是<code>1</code>，即什么都不选。</p><p>​接下来就是我觉得动态规划最让人头疼的状态转移了，对于当前的<code>nums[i]</code>，有两种选择，要么加进背包，要么不加进去，由于我们是要求方法的数量，所以要把<code>nums[i]</code>没放进背包的情况的方法数量加上放进背包的情况。对于<code>dp[i][j]</code>，它的值等于:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mtext>没放进去</mtext><mo>+</mo><mtext>放进去了</mtext></mrow><annotation encoding="application/x-tex">dp[i-1][j]+dp[i-1][j-nums[i]]\\\text{没放进去}+\text{放进去了}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord cjk_fallback">没放进去</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">放进去了</span></span></span></span></span></span></p><p>这式子很好理解，没放进去的话，肯定继承了上一次的数量嘛；放进去的话，就要找一找上一次<strong>没加上这个数</strong>的时候的方法数量。</p><blockquote><p>我知道我这人没多久就会很难理解后面这句话的意思，所以趁着我现在大概能理解，赶紧讲明白：</p><p>把后面的那个<code>dp[i-1][j-nums[i]]</code>的<code>j</code>当做现在的背包的总重量（就是已经把<code>nums[i]</code>装进去了），那么我想知道现在背包的总价值，那我是不是必须得知道没装这个物品的时候，我的背包的总价值？</p><p>这个也同理嘛，想知道我加上这个数（<code>nums[i]</code>)之后一共有多少种方法合成当前的数字(<code>j</code>）？那我起码得知道没加进去（<code>dp[i-1][j-nums[i]]</code>）的时候有多少种方法嘛。</p></blockquote><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            sum += num;        &#125;        <span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || sum &lt; Math.abs(S)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> val = (S + sum) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[val + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = val; j &gt;= num; j--) &#123;                dp[j] = dp[j] + dp[j - num];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[val];    &#125;&#125;</code></pre></div><p>​那么我这里为什么只用了一个一维数组呢？因为我们观察状态转移方程可以知道：当前状态都是上一次状态转移过来的，我们可以用一个一维数组保存数据就可以了。其中<code>dp[i-1][j]</code>和代码中左侧的<code>dp[j]</code>是一样的，在为左边的<code>dp[j]</code>赋值的时候，右边的<code>dp[j]</code>还保存着上一次循环的值，对吧？<code>dp[j-num]</code>也同理。</p><p>​还有，为什么要逆序？为了确保右边的<code>dp[j]</code>和<code>dp[j-num]</code>保存的还是之前的值，拿<code>dp[j-num]</code>来讲：</p><blockquote><p>设<code>dp[10]</code>等于<code>dp[10]+dp[10-4]</code>来讲，如果顺序更新，那我<code>dp[6]</code>是不是比<code>dp[10]</code>先更新？这就不符合我们的要求了嘛</p></blockquote><p>​还有，为什么要以当前的<code>num[i]</code>作为<code>j</code>的下限呢？你总没见过负数的索引吧？况且<code>j</code>可以看为当前的背包容量，如果背包容量不足以装下这个数字，那还装个🔨。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题变种</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>416.分割等和子集</title>
    <link href="/p/7c6d07f7.html"/>
    <url>/p/7c6d07f7.html</url>
    
    <content type="html"><![CDATA[<p>与动态规划作斗争-其一</p><a id="more"></a><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个只包含<strong>正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><p>每个数组中的元素不会超过 100<br />数组的大小不会超过 200<br /><strong>示例 1:</strong></p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]输出: <span class="hljs-literal">true</span>解释: 数组可以分割成 [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>] 和 [<span class="hljs-number">11</span>].</code></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]输出: <span class="hljs-literal">false</span>解释: 数组不能分割成两个元素和相等的子集.</code></pre></div><h1 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h1><p>​题目的两个子集的和相等代表着原来数组的和应该是一个偶数，不然分成两个子集之后，他们的和就不能相等，这是需要判断的一个点。</p><p>​这个问题可以转化为一个0-1背包问题，使用一个二维数组<code>dp[i][s]</code>来表示：</p><blockquote><p>能否从<code>[0,i]</code>的范围内选择一些数字，使得选出来的数字之和恰好等于s。</p></blockquote><p>​我们先看看最基础的状态，比如<code>dp[i][0]</code>这种情况，不管能选多少个数字，我一个都不选，肯定能满足他们之和为0，所以<code>dp[i][0]</code>恒为<code>true</code>，还有<code>dp[0][s]</code>的情况，我没有数字可以选择，怎么我都凑不齐你要的<code>s</code>，所以除了<code>dp[0][0]</code>以外的所有<code>dp[0][s]</code>的值恒为<code>false</code>。</p><p>​根据上面的定义，满足题意的解答是<code>dp[len][sum/2]</code>，其中<code>len</code>是数组的长度，<code>sum</code>是数组的各元素之和。</p><p>​基础状态有了，<code>dp</code>数组的含义也有了，那么就要研究下状态转移了。</p><p>​对于当前的数字<code>nums[i]</code>，考虑<strong>选择</strong>还是<strong>不选</strong>：</p><blockquote><p>不选择： 那么<code>dp[i][s]</code>的值就等于上一次的值，因为这次你没有做任何改变，继承了上一次的值，即<code>dp[i][s] = dp[i-1][s]</code></p><p>选择： <code>dp[i][s]</code>的值取决上一次选择范围内<code>[0,i-1]</code>，有没有数字的和等于<code>s-nums[i]</code>。即<code>dp[i][s] = dp[i-1][s-nums[i-1]]</code>  。</p><p>为什么是<code>nums[i-1]</code>? 因为<code>dp</code>数组的<code>i</code>从1开始算，所以比<code>nums</code>数组的大1。</p><p>为什么是<code>s-nums[i-1]</code>? 因为如果上一次选择范围内有数字之和等于<code>s-nums[i-1]</code>，那么我这次加上<code>nums[i-1]</code>肯定是可以满足和等于<code>s</code>的。</p></blockquote><p>​</p><p>​<strong>为什么从1开始呢？</strong>因为基础状态已经算出<code>i</code>为<code>0</code>的情况和<code>s</code>为<code>0</code>的情况了。</p><p>​对于<strong>示例一</strong>而言：</p><blockquote><p>当然这下面的负数索引在正式编程里会排除掉：</p><p><code>j - nums[i - 1] &lt; 0</code>//代表<strong>和</strong>比待加上去的数小，这在这个正整数数组里是不可能的，换言之就是说背包容量不足了。</p><p><code>dp[i][s]=dp[i-1][s]</code>//只能让他的状况保持原来不变了。</p><p><code>dp[1][1] = dp[0][1] || dp[0][1-1]</code> 根据基础状态可得为真</p><p><code>dp[1][2] = dp[0][2] || dp[0][2-1]</code> 根据基础状态可得为假</p><p>…</p><p>一直到<code>dp[1][11]</code> 都为假。</p><p><code>dp[2][1] = dp[1][1] || dp[1][1-5]</code> 根据之前记录的<code>dp[1][1]</code>可得，为真。</p><p><code>dp[2][2] = dp[1][2] || dp[1][2-5]</code> 根据之前的记录<code>dp[1][2]</code>可得，为假。</p><p>…</p><p><code>dp[2][5] = dp[1][5] || dp[1][5-5]</code> 根据基础状态<code>dp[i][0]</code>可得，为真。</p><p><code>dp[2][6] = dp[1][6] || dp[1][6-1]</code>根据之前的记录<code>dp[1][1]</code>可得，为真。</p><p>…</p><p>一直到<code>dp[2][11]</code>都为假。</p><p>…</p><p>其余状态<code>dp[3][1...11]</code>、<code>dp[4][1...11]</code>同理。</p></blockquote><p>最后返回的结果为<code>dp[4][11]</code>，也就是在整个数组范围<code>[1,4]</code>内，能不能找到一些数，使得他们之和为<code>11</code>，显然有的。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            sum += nums[i];        &#125;        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        sum /= <span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len + <span class="hljs-number">1</span>; i++) &#123;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= sum; j++) &#123;                <span class="hljs-keyword">if</span> (j - nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//容量不足</span>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[len][sum];    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT+Ajax验证</title>
    <link href="/p/6f7d03df.html"/>
    <url>/p/6f7d03df.html</url>
    
    <content type="html"><![CDATA[<p>对Security和JWT的流程有了一定认识之后写的一个Demo</p><a id="more"></a><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>​昨天对整个Spring Security 的鉴权和授权流程有了个大概的了解，作为一个对什么都想自定义的人，肯定要去尝试一波自定义自己的权限管理。</p><p>具体代码可以看：<a href="https://gitee.com/gukkibokou/spring_sql" target="_blank" rel="noopener">Gitee</a> <a href="https://github.com/hukkall/security_jwt_json" target="_blank" rel="noopener">Github</a></p><h1 id="技术栈"><a class="markdownIt-Anchor" href="#技术栈"></a> 技术栈</h1><ul><li>Spring Boot</li><li>Spring Security</li><li>Json Web Token</li><li>MyBatis-Plus</li></ul><h1 id="系统流程"><a class="markdownIt-Anchor" href="#系统流程"></a> 系统流程</h1><h2 id="授权"><a class="markdownIt-Anchor" href="#授权"></a> 授权</h2><img src="/img/image-20200701162121415.png" srcset="/img/loading.gif" alt="image-20200701162121415" style="zoom:80%;" /><h2 id="鉴权"><a class="markdownIt-Anchor" href="#鉴权"></a> 鉴权</h2><img src="/img/image-20200701165911025.png" srcset="/img/loading.gif" alt="image-20200701165911025" style="zoom:80%;" /><h1 id="操作流程"><a class="markdownIt-Anchor" href="#操作流程"></a> 操作流程</h1><h2 id="建表"><a class="markdownIt-Anchor" href="#建表"></a> 建表</h2><div class="hljs"><pre><code class="hljs mysql">&#x2F;* Navicat Premium Data Transfer Source Server         : LOCA Source Server Type    : MySQL Source Server Version : 80019 Source Host           : localhost:3306 Source Schema         : boot_test Target Server Type    : MySQL Target Server Version : 80019 File Encoding         : 65001 Date: 01&#x2F;07&#x2F;2020 17:00:45*&#x2F;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for permission_role-- ----------------------------DROP TABLE IF EXISTS &#96;permission_role&#96;;CREATE TABLE &#96;permission_role&#96;  (  &#96;PREMISSION_ID&#96; int(0) NOT NULL,  &#96;ROLE_ID&#96; int(0) NOT NULL,  INDEX &#96;PREMISSION_ID&#96;(&#96;PREMISSION_ID&#96;) USING BTREE,  INDEX &#96;ROLE_ID1&#96;(&#96;ROLE_ID&#96;) USING BTREE,  CONSTRAINT &#96;PREMISSION_ID&#96; FOREIGN KEY (&#96;PREMISSION_ID&#96;) REFERENCES &#96;premission&#96; (&#96;ID&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT,  CONSTRAINT &#96;ROLE_ID1&#96; FOREIGN KEY (&#96;ROLE_ID&#96;) REFERENCES &#96;role&#96; (&#96;ROLE_ID&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of permission_role-- ----------------------------INSERT INTO &#96;permission_role&#96; VALUES (1, 1);INSERT INTO &#96;permission_role&#96; VALUES (2, 2);-- ------------------------------ Table structure for premission-- ----------------------------DROP TABLE IF EXISTS &#96;premission&#96;;CREATE TABLE &#96;premission&#96;  (  &#96;ID&#96; int(0) NOT NULL,  &#96;PERMISSION&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  PRIMARY KEY (&#96;ID&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of premission-- ----------------------------INSERT INTO &#96;premission&#96; VALUES (1, &#39;check:edit:delete&#39;);INSERT INTO &#96;premission&#96; VALUES (2, &#39;view&#39;);-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS &#96;role&#96;;CREATE TABLE &#96;role&#96;  (  &#96;ROLE_ID&#96; int(0) NOT NULL,  &#96;ROLE_NAME&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  PRIMARY KEY (&#96;ROLE_ID&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of role-- ----------------------------INSERT INTO &#96;role&#96; VALUES (1, &#39;admin&#39;);INSERT INTO &#96;role&#96; VALUES (2, &#39;user&#39;);-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96;  (  &#96;ID&#96; bigint(0) NOT NULL AUTO_INCREMENT,  &#96;NAME&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;PASSWORD&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  PRIMARY KEY (&#96;ID&#96;) USING BTREE) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO &#96;user&#96; VALUES (1, &#39;admin&#39;, &#39;$2a$10$4tCuODS2p98tvk8EWtlhd.Mdbk1mXPwbruD4Y2VL.STIaP2Avz5bi&#39;);INSERT INTO &#96;user&#96; VALUES (2, &#39;user&#39;, &#39;$2a$10$UiSHiNwZdZ2mUSOf7bNCfONRNhMdwAJ37dJ9YVTjPvTfPPKWoLiuy&#39;);-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS &#96;user_role&#96;;CREATE TABLE &#96;user_role&#96;  (  &#96;USER_ID&#96; bigint(0) NOT NULL,  &#96;ROLE_ID&#96; int(0) NOT NULL,  &#96;ID&#96; int(0) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;ID&#96;) USING BTREE,  INDEX &#96;USER_ID&#96;(&#96;USER_ID&#96;) USING BTREE,  INDEX &#96;ROLE_ID&#96;(&#96;ROLE_ID&#96;) USING BTREE,  CONSTRAINT &#96;ROLE_ID&#96; FOREIGN KEY (&#96;ROLE_ID&#96;) REFERENCES &#96;role&#96; (&#96;ROLE_ID&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT,  CONSTRAINT &#96;USER_ID&#96; FOREIGN KEY (&#96;USER_ID&#96;) REFERENCES &#96;user&#96; (&#96;ID&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO &#96;user_role&#96; VALUES (1, 1, 1);INSERT INTO &#96;user_role&#96; VALUES (2, 2, 2);SET FOREIGN_KEY_CHECKS &#x3D; 1;</code></pre></div><h2 id="代码生成"><a class="markdownIt-Anchor" href="#代码生成"></a> 代码生成</h2><p>​这里我使用了Mybatis-Plus的代码生成器</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//1、全局配置</span>        GlobalConfig config = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">"user.dir"</span>);        config.setActiveRecord(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//开启AR模式</span>                .setAuthor(<span class="hljs-string">""</span>)<span class="hljs-comment">//设置作者</span>                .setOutputDir(projectPath + <span class="hljs-string">"/src/main/java"</span>)<span class="hljs-comment">//生成路径(一般在此项目的src/main/java下)</span>                .setFileOverride(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//第二次生成会把第一次生成的覆盖掉</span>                <span class="hljs-comment">//.setSwagger2(true)//实体属性 Swagger2 注解</span>                .setIdType(IdType.AUTO)<span class="hljs-comment">//主键策略</span>                .setServiceName(<span class="hljs-string">"%sService"</span>)<span class="hljs-comment">//生成的service接口名字首字母是否为I，这样设置就没有I</span>                .setBaseResultMap(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//生成resultMap</span>                .setBaseColumnList(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//在xml中生成基础列</span>        <span class="hljs-comment">//2、数据源配置</span>        DataSourceConfig dataSourceConfig = <span class="hljs-keyword">new</span> DataSourceConfig();        dataSourceConfig.setDbType(DbType.MYSQL)<span class="hljs-comment">//数据库类型</span>                .setDriverName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>)                .setUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/xiaoluo?useSSL=true&amp;serverTimezone=GMT"</span>)                .setUsername(<span class="hljs-string">"root"</span>)                .setPassword(<span class="hljs-string">"你的密码"</span>);        <span class="hljs-comment">//3、策略配置</span>        StrategyConfig strategyConfig = <span class="hljs-keyword">new</span> StrategyConfig();        strategyConfig.setCapitalMode(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//开启全局大写命名</span>                .setNaming(NamingStrategy.no_change)<span class="hljs-comment">//表名映射到实体的命名策略(下划线到驼峰)</span>                <span class="hljs-comment">//表字段映射属性名策略(未指定按naming)</span>                .setColumnNaming(NamingStrategy.no_change)                <span class="hljs-comment">//.setTablePrefix("tb_")//表名前缀</span>                <span class="hljs-comment">//.setSuperEntityClass("你自己的父类实体,没有就不用设置!")</span>                <span class="hljs-comment">//.setSuperEntityColumns("id");//写于父类中的公共字段</span>                <span class="hljs-comment">//.setSuperControllerClass("自定义继承的Controller类全称，带包名,没有就不用设置!")</span>                .setRestControllerStyle(<span class="hljs-keyword">true</span>) <span class="hljs-comment">//生成 @RestController 控制器</span>                .setEntityLombokModel(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//使用lombok</span>        <span class="hljs-comment">//4、包名策略配置</span>        PackageConfig packageConfig = <span class="hljs-keyword">new</span> PackageConfig();        packageConfig.setParent(<span class="hljs-string">"com.gukki"</span>)<span class="hljs-comment">//设置包名的parent</span>                .setMapper(<span class="hljs-string">"mapper"</span>)                .setService(<span class="hljs-string">"service"</span>)                .setController(<span class="hljs-string">"controller"</span>)                .setEntity(<span class="hljs-string">"entity"</span>)                .setXml(<span class="hljs-string">"mapper"</span>);<span class="hljs-comment">//设置xml文件的目录</span>        <span class="hljs-comment">//5、整合配置</span>        AutoGenerator autoGenerator = <span class="hljs-keyword">new</span> AutoGenerator();        autoGenerator.setGlobalConfig(config)                .setDataSource(dataSourceConfig)                .setStrategy(strategyConfig)                .setPackageInfo(packageConfig);        <span class="hljs-comment">//6、执行</span>        autoGenerator.execute();</code></pre></div><p>执行即可自动生成代码</p><h2 id="编写jwt工具类-jwtutil"><a class="markdownIt-Anchor" href="#编写jwt工具类-jwtutil"></a> 编写JWT工具类 JWTUtil</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> JWT_TOKEN_VALIDITY = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String key = <span class="hljs-string">"imakeytolong"</span>;    <span class="hljs-comment">//第二个参数意思是指定用什么方法处理这段token</span>    <span class="hljs-comment">//换言之就是调用什么方法去获取这段token里面的值</span>    <span class="hljs-comment">//由T决定返回类型</span>    <span class="hljs-comment">//指定好方法，期望将输入的token 转换为输出值</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">        猜测resolve.apply等价于：&#123;claims-&gt;传入的函数体&#125;</span><span class="hljs-comment">        即，T为函数的返回类型，Claim为传入的函数类型。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getClaimFromToken</span><span class="hljs-params">(String token, Function&lt;Claims, T&gt; resolve)</span> </span>&#123;        Claims claims = getAllClaims(token);        <span class="hljs-keyword">return</span> resolve.apply(claims);    &#125;    <span class="hljs-comment">//注意，这里要用valueOf方法，我在这里出过一次问题。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">getUserID</span><span class="hljs-params">(String token)</span></span>&#123;        <span class="hljs-keyword">return</span> Long.valueOf(getClaimFromToken(token,Claims::getId));    &#125;    <span class="hljs-comment">//Get All Claims</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title">getAllClaims</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody();    &#125;    <span class="hljs-comment">//获取JWT的载荷部分</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getAClaim</span><span class="hljs-params">(String token,String claimName)</span></span>&#123;        <span class="hljs-keyword">return</span> getAllClaims(token).get(claimName).toString();    &#125;    <span class="hljs-comment">//获取主题名，也就是用户名</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUserNameFromToken</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> getClaimFromToken(token, Claims::getSubject);    &#125;    <span class="hljs-comment">//获得token过期时间</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">getExpirationDate</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> getClaimFromToken(token, Claims::getExpiration);    &#125;    <span class="hljs-comment">//查询token 是否过期</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">isExpired</span><span class="hljs-params">(String token)</span> </span>&#123;        Date date = getExpirationDate(token);        <span class="hljs-keyword">return</span> date.before(<span class="hljs-keyword">new</span> Date());    &#125;    <span class="hljs-comment">//生成一串token给用户</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">genKey</span><span class="hljs-params">(SecurityUser details)</span> </span>&#123;        <span class="hljs-keyword">return</span> doGenkey(details);    &#125;    <span class="hljs-comment">//生成</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">doGenkey</span><span class="hljs-params">(SecurityUser details)</span> </span>&#123;        System.out.println(details.getId());        <span class="hljs-keyword">return</span> Jwts.builder()                .setId(String.valueOf(details.getId()))                .claim(<span class="hljs-string">"authorities"</span>, JSON.toJSONString(details.getAuthorities()))                .setSubject(details.getUsername())                .setIssuedAt(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis()))                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * <span class="hljs-number">100</span>))                .signWith(SignatureAlgorithm.HS256, key).compact();    &#125;    <span class="hljs-comment">//校验</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">verifyToken</span><span class="hljs-params">(String token, UserDetails details)</span> </span>&#123;        <span class="hljs-keyword">final</span> String name = details.getUsername();        <span class="hljs-keyword">return</span> (name.equals(getUserNameFromToken(token)) &amp;&amp; !isExpired(token));    &#125;&#125;</code></pre></div><h2 id="编写返回结果类-resutil"><a class="markdownIt-Anchor" href="#编写返回结果类-resutil"></a> 编写返回结果类 ResUtil</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResUtil</span> </span>&#123;    <span class="hljs-comment">//转换为JSON输出</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResponseJSON</span><span class="hljs-params">(ServletResponse resp, Map&lt;String, Object&gt; resultMap)</span> </span>&#123;        PrintWriter pw = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            resp.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);            resp.setContentType(<span class="hljs-string">"application/json"</span>);            pw = resp.getWriter();            pw.println(JSON.toJSONString(resultMap));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            log.error(e.getMessage());        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (pw != <span class="hljs-keyword">null</span>) &#123;                pw.flush();                pw.close();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title">Success</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"result"</span>, <span class="hljs-string">"Success"</span>);        map.put(<span class="hljs-string">"code"</span>, <span class="hljs-number">200</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title">Fail</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"result"</span>, <span class="hljs-string">"Fail"</span>);        map.put(<span class="hljs-string">"code"</span>, <span class="hljs-number">500</span>);        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title">CustomResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span> </span>&#123;        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"result"</span>, msg);        map.put(<span class="hljs-string">"code"</span>, code);        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre></div><h2 id="登录流程"><a class="markdownIt-Anchor" href="#登录流程"></a> 登录流程</h2><h3 id="json认证处理类-jsonauthfilter"><a class="markdownIt-Anchor" href="#json认证处理类-jsonauthfilter"></a> JSON认证处理类 JSONAuthFilter</h3><p>​为了替换掉自带的表单提交，我们需要重写<code>UsernamePasswordAuthenticationFilter</code>类里的<code>attemptAuthentication</code>方法。</p><p>我利用<code>FastJson</code>将提交过来的JSON转换为一个Map，从里面提取到用户名、密码等信息，组装成一个符合Security标准的认证类并请求认证。注意，此时密码和用户名都没认证，所以这个用户的权限信息是<code>null</code>。这些鉴定的事情是交给我自定义的认证类干的。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONAuthFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticationManager</span><span class="hljs-params">(AuthenticationManager authenticationManager)</span> </span>&#123;        <span class="hljs-keyword">super</span>.setAuthenticationManager(authenticationManager);    &#125;    <span class="hljs-meta">@Autowired</span>    LoginSuccessHandler successHandler;    <span class="hljs-meta">@Autowired</span>    LoginFailureHandler failureHandler;    <span class="hljs-meta">@Autowired</span>    AccessDenied accessDenied;    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        log.info(<span class="hljs-string">"进入了JSON登陆许可校验"</span>);        <span class="hljs-keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;            UsernamePasswordAuthenticationToken token = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span>(InputStream inputStream = request.getInputStream()) &#123;                Map&lt;String,String&gt; map = JSON.parseObject(inputStream, Charset.defaultCharset(),Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(map.get(<span class="hljs-string">"username"</span>),map.get(<span class="hljs-string">"password"</span>));                <span class="hljs-comment">//定义好这个过滤器所处理的url</span>                setFilterProcessesUrl(<span class="hljs-string">"/login"</span>);                <span class="hljs-comment">//定义好登陆失败的处理类</span>                setAuthenticationFailureHandler(failureHandler);                <span class="hljs-comment">//定义好登录成功的处理类，这很重要，因为我这里装配JWT的地方就是这个处理类。</span>                setAuthenticationSuccessHandler(successHandler);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                logger.error(e.getMessage());                token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(<span class="hljs-string">""</span>,<span class="hljs-string">""</span>);            &#125;<span class="hljs-keyword">finally</span> &#123;                setDetails(request,token);                <span class="hljs-comment">//请求认证，这就调用了我的自定义的认证类。</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(token);            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request,response);        &#125;    &#125;&#125;</code></pre></div><h3 id="自定义的认证类-customauthprovider"><a class="markdownIt-Anchor" href="#自定义的认证类-customauthprovider"></a> 自定义的认证类 CustomAuthProvider</h3><p>​得到上面传来的用户名和密码，我们就需要从数据库里面拿到对应用户名的个人信息并进行比对了，匹配成功之后我们就可以去认证成功类装配JWT了。若想实现自定义认证，需要实现<code>AuthenticationProvider</code>这个类下的<code>authenticate</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CustomUserDetailService userDetailService;    <span class="hljs-meta">@Autowired</span>    UserRoleService userRoleService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        log.info(<span class="hljs-string">"进入了登录监测"</span>);        String name = (String) authentication.getPrincipal();        String password = (String) authentication.getCredentials();        SecurityUser user = userDetailService.loadUserByUsername(name);        log.info(user.toString());        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"未找到用户名"</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span> BCryptPasswordEncoder().matches(password, user.getPassword())) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"密码错误"</span>);        &#125;        <span class="hljs-comment">// 获取角色列表</span>        HashSet&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">/*</span><span class="hljs-comment">        SELECT</span><span class="hljs-comment">            role.ROLE_ID,</span><span class="hljs-comment">            role.ROLE_NAME</span><span class="hljs-comment">        FROM</span><span class="hljs-comment">            role</span><span class="hljs-comment">                LEFT JOIN</span><span class="hljs-comment">            user_role</span><span class="hljs-comment">            ON</span><span class="hljs-comment">                role.ROLE_ID = user_role.ROLE_ID</span><span class="hljs-comment">        WHERE</span><span class="hljs-comment">            user_role.USER_ID = #&#123;id&#125;</span><span class="hljs-comment">        */</span>        List&lt;Role&gt; list = userRoleService.getRoleByID(user.getId());        <span class="hljs-comment">//Lambda 表达式 将获取到的角色处理之后放入用户信息中的权限组</span>        list.forEach(userRole -&gt; authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_"</span> + userRole.getRoleName())));        user.setAuthorities(authorities);        <span class="hljs-comment">//认证成功之后返回一个充满了用户信息的类，以及他所有的权限信息。</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user, <span class="hljs-keyword">null</span>, authorities);    &#125;    <span class="hljs-comment">//其实这里可以做一些判断，判断传入的认证类是否被这个所支持。</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="自定义认证成功类-loginsuccesshandler"><a class="markdownIt-Anchor" href="#自定义认证成功类-loginsuccesshandler"></a> 自定义认证成功类 LoginSuccessHandler</h3><p>​这个类功能很简单，如果认证成功之后认证类会传回一个充满个人信息的认证类，我们将这个类组装成一个JWT，并且返回给用户。</p><p>若想实现这个功能，需实现<code>AuthenticationSuccessHandler</code>下的<code>onAuthenticationSuccess</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        SecurityUser user = (SecurityUser) authentication.getPrincipal();        log.info(user.toString());        String token = JWTUtil.genKey(user);        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"token"</span>,token);        ResUtil.ResponseJSON(response,map);    &#125;&#125;</code></pre></div><p>这样的话，用户就能拿到他的token了。</p><h3 id="注册到spring-security-securityconfig"><a class="markdownIt-Anchor" href="#注册到spring-security-securityconfig"></a> 注册到Spring Security SecurityConfig</h3><p>​写完这些类还不算完，需要将其注册到Security的配置里面去。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    JSONAuthFilter filter;    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ...        http.addFilterAt(filter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>登录的流程就差不多了，可以看下结果：</p><p><img src="/img/image-20200701180435010.png" srcset="/img/loading.gif" alt="image-20200701180435010" /></p><h2 id="鉴权流程"><a class="markdownIt-Anchor" href="#鉴权流程"></a> 鉴权流程</h2><h3 id="token认证类-jwtauthfilter"><a class="markdownIt-Anchor" href="#token认证类-jwtauthfilter"></a> Token认证类 JWTAuthFilter</h3><p>​由于JWT是一种无状态的应用授权方式，即，服务器不保存用户信息，而是用户每次访问的时候都要带上JWT。所以需要一个类去获取到请求头上的Token并进行解析与认证。需要继承<code>BasicAuthenticationFilter</code>并重写<code>doFilterInternal</code>方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-comment">//认证</span><span class="hljs-comment">//流程：检查请求头有无认证信息，有-&gt;从Token中获取用户信息，获取角色组-&gt;组装成一个用户信息类（继承了UserDetails）—&gt;封装成一个认证类-&gt;提交至安全上下文。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTAuthFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasicAuthenticationFilter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTAuthFilter</span><span class="hljs-params">(AuthenticationManager manager)</span> </span>&#123;        <span class="hljs-keyword">super</span>(manager);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        log.info(<span class="hljs-string">"进入了Token认证"</span>);        String header = request.getHeader(<span class="hljs-string">"Authorization"</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != header &amp;&amp; header.startsWith(<span class="hljs-string">"Bearer "</span>)) &#123;            String token = header.substring(<span class="hljs-number">7</span>);            <span class="hljs-comment">//Get name</span>            String name = JWTUtil.getUserNameFromToken(token);            <span class="hljs-comment">//Get ID</span>            Long ID = JWTUtil.getUserID(token);            <span class="hljs-comment">//获取角色</span>            <span class="hljs-keyword">if</span> (!name.isEmpty() &amp;&amp; (ID != <span class="hljs-keyword">null</span>)) &#123;                <span class="hljs-keyword">try</span> &#123;                    List&lt;GrantedAuthority&gt; authorityList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                    String authority = JWTUtil.getAClaim(token, <span class="hljs-string">"authorities"</span>);                    <span class="hljs-keyword">if</span> (!authority.isEmpty()) &#123;                        <span class="hljs-comment">//[&#123;"authority":"ROLE_USER"&#125;,&#123;"authority":"ROLE_ADMIN"&#125;]</span>                        List&lt;Map&lt;String, String&gt;&gt; authorityMap = JSONObject.parseObject(authority, List<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-keyword">for</span> (Map&lt;String, String&gt; map : authorityMap) &#123;                            <span class="hljs-keyword">if</span> (!map.isEmpty()) &#123;                                authorityList.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(map.get(<span class="hljs-string">"authority"</span>)));                            &#125;                        &#125;                        SecurityUser user = <span class="hljs-keyword">new</span> SecurityUser(ID, name, authorityList);                        UsernamePasswordAuthenticationToken token1 = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user, <span class="hljs-keyword">null</span>, authorityList);                        <span class="hljs-comment">//保存到安全上下文，等会鉴权时用到。</span>                        SecurityContextHolder.getContext().setAuthentication(token1);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (ExpiredJwtException e) &#123;                    logger.error(e.getMessage());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    logger.error(e.getMessage());                &#125;            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;&#125;</code></pre></div><h3 id="注册到spring-security"><a class="markdownIt-Anchor" href="#注册到spring-security"></a> 注册到Spring Security</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ...        http.addFilter(<span class="hljs-keyword">new</span> JWTAuthFilter(authenticationManager()));    &#125;&#125;</code></pre></div><p>一般来讲，如果是以角色(<code>hasRole</code>)来判断能否访问资源的话（就像下面的一样），到这里就结束了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('admin')"</span>)    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/admin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Success"</span>;    &#125;</code></pre></div><p>但是有时事情并没有那么简单，比如多人合作的一份文档，有人可以编辑，有人可以删除，有人只可以查看，所以我们要把权限控制的粒度细化一些。也就是说什么人可以干什么事情之类的，但是我这里<strong>没这样写</strong>，<s>只能等以后了</s>。只写了一个什么角色对有着什么操作权限，对于一个已经限定好操作权限的资源，不管你的角色是什么，只要你有它所要求的权限就可以对他操作了。</p><h3 id="自定义权限比较器-customevaluator"><a class="markdownIt-Anchor" href="#自定义权限比较器-customevaluator"></a> 自定义权限比较器 CustomEvaluator</h3><p>​需要实现<code>PermissionEvaluator</code>下的<code>hasPermission</code>方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PermissionRoleService service;    <span class="hljs-comment">//authentication 会自动传进去的。</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetDomainObject, Object permission)</span> </span>&#123;        SecurityUser user = (SecurityUser) authentication.getPrincipal();        Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();        Set&lt;String&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        List&lt;Permission&gt; permissionList = service.getPremissionByID(user.getId());        permissionList.forEach(item -&gt; &#123;permissions.add(item.getPermission());&#125;);        <span class="hljs-keyword">if</span>(permissions.contains(permission.toString())) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>对于：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission('/user/user','view:edit')"</span>)    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User Success"</span>;    &#125;</code></pre></div><p>这种形式的的，只要你的权限里面有<code>view:edit</code>这两个权限，都可以访问这个链接。</p><p>-大概就结束了？</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT学习</title>
    <link href="/p/cec8f3e6.html"/>
    <url>/p/cec8f3e6.html</url>
    
    <content type="html"><![CDATA[<p>一个新手对于JWT的认识</p><a id="more"></a><h1 id="jwt-学习"><a class="markdownIt-Anchor" href="#jwt-学习"></a> JWT 学习</h1><h2 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1、概念</h2><p>​ JWT(Jason Web Token)按照我个人理解，是一串服务端按照特定的加密算法生成的字符串。</p><p>​在用户登录成功之后，服务器将用户的个人信息加密并签名成一串字符串发送回用户浏览器，在每次访问受权限控制的网页的时候将这串字符串发回给服务器，用于证明“你还是你”。然后服务端可以解密这串字符串，从里面拿到用户的相关信息，并判断用户有无权限访问此页面。</p><p>​绿小萝的开发中，我们采用了传统的session来记录用户信息，这样在本地或者说单机开发是没有什么问题。但是一旦出现前后端分别处于不同的服务器里，产生了跨域的问题，这样的话session就比较难处理了。</p><p>​采用JWT的话，服务器不保存用户的session，只凭JWT里面的信息来鉴别用户，这样的话，跨域就变得很简单了。</p><p>​JWT这个字符串由三个结构组成</p><blockquote><ul><li>头部(Header)</li><li>“alg” 加密类型</li><li>“typ” 这串token的类型，自然是JWT</li><li>载荷(PayLoad)</li><li>可自定义，采用键值对的方式</li><li>签名</li><li>与服务端指定的密匙有关</li></ul></blockquote><p>​附：我们使用的session认证流程：</p><blockquote><ol><li>用户登录，发送用户名和密码到后台</li><li>后台验证通过之后，将从数据库取出来的用户信息保存到session里</li><li>后台向用户浏览器返回一个session_id，写入浏览器的cookie里。</li><li>之后的每一个请求，都会将cookie里面的session_id发送回后台</li><li>后台通过前台传来的session_id，找到保存起来的session，并从里面取得用户信息。</li></ol></blockquote><h2 id="2-小试牛刀"><a class="markdownIt-Anchor" href="#2-小试牛刀"></a> 2、小试牛刀</h2><p>​网上找了个教程，讲的很好，我模仿他的例子，加上了自己理解的注释：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        String s = genToken();        verifyToken(s);    &#125;<span class="hljs-comment">//生成JWT</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">genToken</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//先生成token，预设好一个Key</span>        String secret = <span class="hljs-string">"imkey"</span>;        <span class="hljs-comment">//加密</span>        Algorithm algorithm = Algorithm.HMAC256(secret);        <span class="hljs-comment">//设置头部信息</span>        <span class="hljs-comment">//也就是加密算法类型以及token类型</span>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"alg"</span>, <span class="hljs-string">"HS256"</span>);        map.put(<span class="hljs-string">"typ"</span>, <span class="hljs-string">"JWT"</span>);        <span class="hljs-comment">//设置载荷（payload）</span>        String token = JWT.create()                <span class="hljs-comment">//定义头部</span>                .withHeader(map)                <span class="hljs-comment">//自定义载荷</span>                .withClaim(<span class="hljs-string">"name"</span>, <span class="hljs-string">"李一"</span>)                <span class="hljs-comment">//定义主题</span>                .withSubject(<span class="hljs-string">"一个token"</span>)                <span class="hljs-comment">//签名头部</span>                .sign(algorithm);        <span class="hljs-keyword">return</span> token;    &#125;<span class="hljs-comment">//校验JWT</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyToken</span><span class="hljs-params">(String token)</span></span>&#123;        <span class="hljs-comment">//定义加密类型</span>        Algorithm algorithm = Algorithm.HMAC256(<span class="hljs-string">"imkey"</span>);        <span class="hljs-comment">//获取这种算法的对应的解密（校验）对象</span>        JWTVerifier require = JWT.require(algorithm)                .build();        System.out.println(require);        <span class="hljs-comment">//解密</span>        DecodedJWT decodedJWT = require.verify(token);        <span class="hljs-comment">//获取载荷里面的值</span>        Claim claim = decodedJWT.getClaim(<span class="hljs-string">"name"</span>);        System.out.println(claim);        <span class="hljs-comment">//输出载荷的值</span>        System.out.println(claim.asString());    &#125;</code></pre></div><p>运行结果如下：</p><p><img src="/img/image-20200626083111707-1593413542002.png" srcset="/img/loading.gif" alt="image-20200626083111707" /></p><p>是没有问题的。</p><h2 id="3-使用ajax发送用户信息并进行登录认证的jwt应用"><a class="markdownIt-Anchor" href="#3-使用ajax发送用户信息并进行登录认证的jwt应用"></a> 3、使用ajax发送用户信息并进行登录认证的JWT应用</h2><p>​项目结构如下所示</p><p><img src="/img/image-20200626122914327.png" srcset="/img/loading.gif" alt="image-20200626122914327" /></p><p>流程图（<a href="https://www.cnblogs.com/fishpro/p/spring-boot-study-securing-jwt.html" target="_blank" rel="noopener">引用了一个大佬的图</a>，详情请见本章末尾）</p><p><img src="/img/o_jwt2.jpg" srcset="/img/loading.gif" alt="o_jwt2" /></p><p><img src="/img/o_jwt3.jpg" srcset="/img/loading.gif" alt="o_jwt3" /></p><p><img src="/img/o_jwt4.jpg" srcset="/img/loading.gif" alt="o_jwt4" /></p><p><strong>JwtAuthenticationController</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于验证 jwt 返回客户端 jwt（json web token）</span><span class="hljs-comment"> * */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@CrossOrigin</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtAuthenticationController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtTokenUtil jwtTokenUtil;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtUserDetailsService userDetailsService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取 客户端来的 username password 使用秘钥加密成 json web token</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/authenticate"</span>, method = RequestMethod.POST)    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; createAuthenticationToken(<span class="hljs-meta">@RequestBody</span> JwtRequest authenticationRequest) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//获取前台传来的明文账号密码并进行认证</span>        authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());        <span class="hljs-comment">//认证操作成功后，以下的语句才会执行</span>        <span class="hljs-comment">//获取用户信息</span>        <span class="hljs-keyword">final</span> UserDetails userDetails = userDetailsService                .loadUserByUsername(authenticationRequest.getUsername());        <span class="hljs-comment">//生成token</span>        <span class="hljs-keyword">final</span> String token = jwtTokenUtil.generateToken(userDetails);        <span class="hljs-comment">//向前台返回序列化后的token</span>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-keyword">new</span> JwtResponse(token));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  获取 客户端来的 username password 使用秘钥加密成 json web token</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建一个没有认证的token实例，此时“是否身份认证过”属性为false</span>            <span class="hljs-comment">//由于此时未进行身份认证，所以他的权限未知</span>            <span class="hljs-comment">//认证信息管理（authenticationManager），从指定的用户数据源加载用户信息</span>            <span class="hljs-comment">//然后使用约定好的加密方式，进行认证。</span>            <span class="hljs-comment">//认证失败之后，直接返回给前台401</span>            authenticationManager.authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password));        &#125; <span class="hljs-keyword">catch</span> (DisabledException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"USER_DISABLED"</span>, e);        &#125; <span class="hljs-keyword">catch</span> (BadCredentialsException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"INVALID_CREDENTIALS"</span>, e);        &#125;    &#125;&#125;</code></pre></div><p><strong>JwtAuthenticationEntryPoint</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AuthenticationEntryPoint 用来解决匿名用户访问无权限资源时的异常</span><span class="hljs-comment"> * AccessDeineHandler 用来解决认证过的用户访问无权限资源时的异常</span><span class="hljs-comment"> * */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtAuthenticationEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationEntryPoint</span>, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">7858869558953243875L</span>;    <span class="hljs-comment">//当出错的时候 发送 Unauthorized</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">                         AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, <span class="hljs-string">"Unauthorized"</span>);    &#125;&#125;</code></pre></div><p><strong>JwtRequestFilter</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 过滤器 用于 Spring Boot Security</span><span class="hljs-comment"> * OncePerRequestFilter 一次请求只通过一次filter，而不需要重复执行</span><span class="hljs-comment"> * */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtRequestFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtUserDetailsService jwtUserDetailsService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtTokenUtil jwtTokenUtil;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//获得请求头</span>        <span class="hljs-keyword">final</span> String requestTokenHeader = request.getHeader(<span class="hljs-string">"Authorization"</span>);        String username = <span class="hljs-keyword">null</span>;        String jwtToken = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// JWT Token 获取请求头部的 Bearer</span>        <span class="hljs-comment">// only the Token</span>        <span class="hljs-keyword">if</span> (requestTokenHeader != <span class="hljs-keyword">null</span> &amp;&amp; requestTokenHeader.startsWith(<span class="hljs-string">"Bearer "</span>)) &#123;            jwtToken = requestTokenHeader.substring(<span class="hljs-number">7</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//从token里获取用户名</span>                username = jwtTokenUtil.getUsernameFromToken(jwtToken);            &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;                System.out.println(<span class="hljs-string">"Unable to get JWT Token"</span>);            &#125; <span class="hljs-keyword">catch</span> (ExpiredJwtException e) &#123;                System.out.println(<span class="hljs-string">"JWT Token has expired"</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            logger.warn(<span class="hljs-string">"JWT Token does not begin with Bearer String"</span>);        &#125;        <span class="hljs-comment">// 验证</span>        <span class="hljs-keyword">if</span> (username != <span class="hljs-keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//我猜，之所以要在这里再校验一次用户名，是防止上面的异常抛出的后，username为空的情况。</span>            <span class="hljs-comment">//获取用户的在后台保存的账号密码，封装成一个对象，通过查询用户名的方式</span>            UserDetails userDetails = <span class="hljs-keyword">this</span>.jwtUserDetailsService.loadUserByUsername(username);            <span class="hljs-comment">// JWT 验证通过 使用Spring Security 管理</span>            <span class="hljs-comment">//将token里面的用户名和保存的对象进行校验</span>            <span class="hljs-keyword">if</span> (jwtTokenUtil.validateToken(jwtToken, userDetails)) &#123;                <span class="hljs-comment">//传入用户信息，</span>                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                        userDetails, <span class="hljs-keyword">null</span>, userDetails.getAuthorities());                usernamePasswordAuthenticationToken                        .setDetails(<span class="hljs-keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));                <span class="hljs-comment">// After setting the Authentication in the context, we specify</span>                <span class="hljs-comment">// that the current user is authenticated. So it passes the</span>                <span class="hljs-comment">// Spring Security Configurations successfully.</span>                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);            &#125;        &#125;        <span class="hljs-comment">//没有token，则跑去jwtcontroller</span>        chain.doFilter(request, response);    &#125;&#125;</code></pre></div><p><strong>JwtUserDetailsService</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//用户信息来源</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<span class="hljs-comment">//通过用户名加载</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javainuse"</span>.equals(username)) &#123;            <span class="hljs-comment">//新建一个用户名为：javainuse的用户，密码为用BC加密的password,后面的数组是这个用户的权限列表，目前为空。</span>            <span class="hljs-comment">//BC加密后的字符串有着它特殊的意思，前面的2a表示使用了bc加密，后面的10表示它hash了10次</span>            <span class="hljs-comment">//然后从第三个$开始算起的21个字符都是它的salt，用于混淆用的</span>            <span class="hljs-comment">//后面的全都是密文密码和slat hash10次之后的密文</span>            <span class="hljs-comment">//如何校验？</span>            <span class="hljs-comment">//获得前台传来的明文密码，取储存好的BC加密后的字符串，取其中的盐，hash10次之后，和密文进行匹配。</span>            <span class="hljs-comment">//返回用户的用户名、BC加密后的密码、以及权限列表。</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"javainuse"</span>, <span class="hljs-string">"$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6"</span>,                    <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"User not found with username: "</span> + username);        &#125;    &#125;&#125;</code></pre></div><p><strong>WebSecurityConfig</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDetailsService jwtUserDetailsService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JwtRequestFilter jwtRequestFilter;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// configure AuthenticationManager so that it knows from where to load</span>        <span class="hljs-comment">// user for matching credentials</span>        <span class="hljs-comment">// Use BCryptPasswordEncoder</span>        <span class="hljs-comment">//配置用于用户信息来源，并设置好加密方式</span>        auth.userDetailsService(jwtUserDetailsService).passwordEncoder(passwordEncoder());    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 本示例不需要使用CSRF</span>        httpSecurity.csrf().disable()                <span class="hljs-comment">// 认证页面不需要权限</span>                .authorizeRequests().antMatchers(<span class="hljs-string">"/authenticate"</span>).permitAll().                <span class="hljs-comment">//其他页面</span>                        anyRequest().authenticated().and().                <span class="hljs-comment">//登录页面 模拟客户端</span>                formLogin().loginPage(<span class="hljs-string">"/login.html"</span>).permitAll().and().                <span class="hljs-comment">// store user's state.</span>                 exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().sessionManagement()                <span class="hljs-comment">//不使用session</span>                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);        <span class="hljs-comment">//验证请求是否正确</span>        httpSecurity.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p><strong>HelloWorldController</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(&#123; <span class="hljs-string">"/hello"</span> &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">firstPage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World"</span>;    &#125;&#125;</code></pre></div><p><strong>JwtRequest</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtRequest</span></span>&#123;   <span class="hljs-comment">// private static final long serialVersionUID = 5926468583005150707L;</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">//need default constructor for JSON Parsing</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtRequest</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtRequest</span><span class="hljs-params">(String username, String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.setUsername(username);        <span class="hljs-keyword">this</span>.setPassword(password);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;&#125;</code></pre></div><p><strong>JwtResponse</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtResponse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">8091879091924046844L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String jwttoken;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtResponse</span><span class="hljs-params">(String jwttoken)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jwttoken = jwttoken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jwttoken;    &#125;&#125;</code></pre></div><p><strong>JwtTokenUtil</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2550185165626007488L</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> JWT_TOKEN_VALIDITY = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;jwt.secret&#125;"</span>)    <span class="hljs-keyword">private</span> String secret;    <span class="hljs-comment">//retrieve username from jwt token</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsernameFromToken</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> getClaimFromToken(token, Claims::getSubject);    &#125;    <span class="hljs-comment">//retrieve expiration date from jwt token</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getExpirationDateFromToken</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> getClaimFromToken(token, Claims::getExpiration);    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getClaimFromToken</span><span class="hljs-params">(String token, Function&lt;Claims, T&gt; claimsResolver)</span> </span>&#123;        <span class="hljs-keyword">final</span> Claims claims = getAllClaimsFromToken(token);        <span class="hljs-keyword">return</span> claimsResolver.apply(claims);    &#125;    <span class="hljs-comment">//for retrieveing any information from token we will need the secret key</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Claims <span class="hljs-title">getAllClaimsFromToken</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">return</span> Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();    &#125;    <span class="hljs-comment">//check if the token has expired</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Boolean <span class="hljs-title">isTokenExpired</span><span class="hljs-params">(String token)</span> </span>&#123;        <span class="hljs-keyword">final</span> Date expiration = getExpirationDateFromToken(token);        <span class="hljs-keyword">return</span> expiration.before(<span class="hljs-keyword">new</span> Date());    &#125;    <span class="hljs-comment">//generate token for user</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateToken</span><span class="hljs-params">(UserDetails userDetails)</span> </span>&#123;        Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">return</span> doGenerateToken(claims, userDetails.getUsername());    &#125;    <span class="hljs-comment">//while creating the token -</span>    <span class="hljs-comment">//1. Define  claims of the token, like Issuer, Expiration, Subject, and the ID</span>    <span class="hljs-comment">//2. Sign the JWT using the HS512 algorithm and secret key.</span>    <span class="hljs-comment">//3. According to JWS Compact Serialization(https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-3.1)</span>    <span class="hljs-comment">//   compaction of the JWT to a URL-safe string</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">doGenerateToken</span><span class="hljs-params">(Map&lt;String, Object&gt; claims, String subject)</span> </span>&#123;        <span class="hljs-keyword">return</span> Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis()))                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * <span class="hljs-number">1000</span>))                .signWith(SignatureAlgorithm.HS512, secret).compact();    &#125;    <span class="hljs-comment">//校验 token</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">validateToken</span><span class="hljs-params">(String token, UserDetails userDetails)</span> </span>&#123;        <span class="hljs-comment">//获取token的用户名，并进行匹配</span>        <span class="hljs-keyword">final</span> String username = getUsernameFromToken(token);        <span class="hljs-keyword">return</span> (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));    &#125;&#125;</code></pre></div><p>登录用的ajax：</p><div class="hljs"><pre><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        $(<span class="hljs-string">"#btnSave"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">var</span> username=$(<span class="hljs-string">"#userName"</span>).val();            <span class="hljs-keyword">var</span> password=$(<span class="hljs-string">"#password"</span>).val();            $.ajax(&#123;                cache: <span class="hljs-literal">true</span>,                type: <span class="hljs-string">"POST"</span>,                url: <span class="hljs-string">"/authenticate"</span>,                contentType: <span class="hljs-string">"application/json;charset=UTF-8"</span>,                data:<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-string">"username"</span>:username ,<span class="hljs-string">"password"</span> : password&#125;),                dataType: <span class="hljs-string">"json"</span>,                <span class="hljs-keyword">async</span>: <span class="hljs-literal">false</span>,                error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request</span>) </span>&#123;                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Connection error"</span>);                &#125;,                success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;                    <span class="hljs-comment">//save token</span>                    localStorage.setItem(<span class="hljs-string">"token"</span>,data.token);                &#125;            &#125;);        &#125;);    &#125;);</code></pre></div><p>注意，这个项目的java版本要求是java8，如果你是和我一样使用java11或更高的版本的话，可以使用我的pom.xml里面的配置。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>参考来源：</p><p><a href="https://www.cnblogs.com/fishpro/p/spring-boot-study-securing-jwt.html" target="_blank" rel="noopener">Spring Boot Security JWT 整合实现前后端分离认证示例</a></p><p><a href="https://www.javainuse.com/spring/boot-jwt" target="_blank" rel="noopener">Spring Boot Security + JWT Hello World Example</a></p><h2 id="4-jwt数据库-授权部分"><a class="markdownIt-Anchor" href="#4-jwt数据库-授权部分"></a> 4、 JWT+数据库 授权部分</h2><p>​我觉得这玩意可难了，学了个两天才勉勉强强搞明白个一小半。唉，吃了英语不好的亏。</p><p>​以下是大概的流程：</p><img src="/img/image-20200628170759526.png" srcset="/img/loading.gif" alt="A" style="zoom: 100%;" /><p>所用到的类：</p><h3 id="拦截器类-jwtauthenticationtokenfilter"><a class="markdownIt-Anchor" href="#拦截器类-jwtauthenticationtokenfilter"></a> 拦截器类 JWTAuthenticationTokenFilter</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTAuthenticationTokenFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasicAuthenticationFilter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTAuthenticationTokenFilter</span><span class="hljs-params">(AuthenticationManager authenticationManager)</span> </span>&#123;        <span class="hljs-keyword">super</span>(authenticationManager);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">// 获取请求头中JWT的Token</span>        String tokenHeader = request.getHeader(JWTConfig.tokenHeader);        <span class="hljs-comment">// &amp;&amp; tokenHeader.startsWith(JWTConfig.tokenPrefix)</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span>!=tokenHeader) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 截取JWT前缀</span>                String token = tokenHeader.replace(<span class="hljs-string">"Bearer Sans-"</span>, <span class="hljs-string">""</span>);                <span class="hljs-comment">// 解析JWT</span>                Claims claims = Jwts.parser()                        .setSigningKey(JWTConfig.secret)                        .parseClaimsJws(token)                        .getBody();                log.info(claims.toString());                <span class="hljs-comment">// 获取用户名</span>                String username = claims.getSubject();                String userId=claims.getId();                <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(username)&amp;&amp;!StringUtils.isEmpty(userId)) &#123;                    <span class="hljs-comment">// 获取角色</span>                    List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                    String authority = claims.get(<span class="hljs-string">"authorities"</span>).toString();                    log.info(authority);                    <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(authority))&#123;                        List&lt;Map&lt;String,String&gt;&gt; authorityMap = JSONObject.parseObject(authority, List<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-keyword">for</span> (Map&lt;String, String&gt; stringStringMap : authorityMap) &#123;                            <span class="hljs-keyword">for</span> (String s : stringStringMap.keySet()) &#123;                                log.info(s);                                log.info(stringStringMap.get(s));                            &#125;                        &#125;                        <span class="hljs-keyword">for</span>(Map&lt;String,String&gt; role : authorityMap)&#123;                            <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(role)) &#123;                                authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.get(<span class="hljs-string">"authority"</span>)));                                <span class="hljs-comment">//log.info(role.get("authority"));</span>                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">//组装参数</span>                    SelfUserEntity selfUserEntity = <span class="hljs-keyword">new</span> SelfUserEntity();                    selfUserEntity.setUsername(claims.getSubject());                    selfUserEntity.setUserId(Long.parseLong(claims.getId()));                    selfUserEntity.setAuthorities(authorities);                    UsernamePasswordAuthenticationToken authentication = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(selfUserEntity, userId, authorities);                    SecurityContextHolder.getContext().setAuthentication(authentication);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ExpiredJwtException e)&#123;                log.info(<span class="hljs-string">"Token过期"</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(e.getMessage());                log.info(<span class="hljs-string">"Token无效"</span>);            &#125;        &#125;        filterChain.doFilter(request, response);        <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></div><h3 id="security配置类-securityconfig"><a class="markdownIt-Anchor" href="#security配置类-securityconfig"></a> Security配置类 SecurityConfig</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>) <span class="hljs-comment">//开启权限注解,默认是关闭的</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义登录成功处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserLoginSuccessHandler userLoginSuccessHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义登录失败处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserLoginFailureHandler userLoginFailureHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义注销成功处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserLogoutSuccessHandler userLogoutSuccessHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义暂无权限处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserAuthAccessDeniedHandler userAuthAccessDeniedHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义未登录的处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserAuthenticationEntryPointHandler userAuthenticationEntryPointHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义登录逻辑验证器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserAuthenticationProvider userAuthenticationProvider;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 加密方式</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/10/1 14:00</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BCryptPasswordEncoder <span class="hljs-title">bCryptPasswordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注入自定义PermissionEvaluator</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityExpressionHandler <span class="hljs-title">userSecurityExpressionHandler</span><span class="hljs-params">()</span></span>&#123;        DefaultWebSecurityExpressionHandler handler = <span class="hljs-keyword">new</span> DefaultWebSecurityExpressionHandler();        handler.setPermissionEvaluator(<span class="hljs-keyword">new</span> UserPermissionEvaluator());        <span class="hljs-keyword">return</span> handler;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置登录验证逻辑</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span></span>&#123;        <span class="hljs-comment">//这里可启用我们自己的登陆验证逻辑</span>        auth.authenticationProvider(userAuthenticationProvider);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置security的控制逻辑</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/10/1 16:56</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  http 请求</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                <span class="hljs-comment">// 不进行权限验证的请求或资源(从配置文件中读取)</span>               .antMatchers(JWTConfig.antMatchers.split(<span class="hljs-string">","</span>)).permitAll()                <span class="hljs-comment">// 其他的需要登陆后才能访问</span>                .anyRequest().authenticated()                .and()                <span class="hljs-comment">// 配置未登录自定义处理类</span>                .httpBasic().authenticationEntryPoint(userAuthenticationEntryPointHandler)                .and()                <span class="hljs-comment">// 配置登录地址</span>                .formLogin()                .loginProcessingUrl(<span class="hljs-string">"/login/userLogin"</span>)                <span class="hljs-comment">// 配置登录成功自定义处理类</span>                .successHandler(userLoginSuccessHandler)                <span class="hljs-comment">// 配置登录失败自定义处理类</span>                .failureHandler(userLoginFailureHandler)                .and()                <span class="hljs-comment">// 配置登出地址</span>                .logout()                .logoutUrl(<span class="hljs-string">"/login/userLogout"</span>)                <span class="hljs-comment">// 配置用户登出自定义处理类</span>                .logoutSuccessHandler(userLogoutSuccessHandler)                .and()                <span class="hljs-comment">// 配置没有权限自定义处理类</span>                .exceptionHandling().accessDeniedHandler(userAuthAccessDeniedHandler)                .and()                <span class="hljs-comment">// 开启跨域</span>                .cors()                .and()                <span class="hljs-comment">// 取消跨站请求伪造防护</span>                .csrf().disable();        <span class="hljs-comment">// 基于Token不需要session</span>        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);        <span class="hljs-comment">// 禁用缓存</span>        http.headers().cacheControl();        <span class="hljs-comment">// 添加JWT过滤器</span>        http.addFilter(<span class="hljs-keyword">new</span> JWTAuthenticationTokenFilter(authenticationManager()));    &#125;&#125;</code></pre></div><h3 id="角色实体类-sysroleentity"><a class="markdownIt-Anchor" href="#角色实体类-sysroleentity"></a> 角色实体类 SysRoleEntity</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@TableName</span>(<span class="hljs-string">"sys_role"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysRoleEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 角色ID</span><span class="hljs-comment"> */</span><span class="hljs-meta">@TableId</span><span class="hljs-keyword">private</span> Long roleId;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 角色名称</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String roleName;&#125;</code></pre></div><h3 id="自定义认证逻辑处理器-userauthenticationprovider"><a class="markdownIt-Anchor" href="#自定义认证逻辑处理器-userauthenticationprovider"></a> 自定义认证逻辑处理器 UserAuthenticationProvider</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SelfUserDetailsService selfUserDetailsService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SysUserService sysUserService;    <span class="hljs-comment">//authentication 这个参数是哪里来的呢？</span>    <span class="hljs-comment">//我猜测是这样的：UsernamePasswordAuthenticationFilter 处理了从前台传入的账号密码，封装成一个实现了Authentication接口的UsernamePasswordAuthenticationToken类，此时这个账号密码尚未认证，所以没有权限。-&gt;调用ProviderManager类的authenticate方法处理Token-&gt;轮询在security配置里面注册好的登录逻辑处理类，检查是否支持当前token，找到之后进行处理。—&gt;于是，这个token就传进来了。</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">// 获取表单输入中返回的用户名</span>        String userName = (String) authentication.getPrincipal();        <span class="hljs-comment">// 获取表单中输入的密码</span>        String password = (String) authentication.getCredentials();        <span class="hljs-comment">// 查询用户是否存在</span>        SelfUserEntity userInfo = selfUserDetailsService.loadUserByUsername(userName);        <span class="hljs-keyword">if</span> (userInfo == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户名不存在"</span>);        &#125;        <span class="hljs-comment">// 我们还要判断密码是否正确，这里我们的密码使用BCryptPasswordEncoder进行加密的</span>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span> BCryptPasswordEncoder().matches(password, userInfo.getPassword())) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"密码不正确"</span>);        &#125;        <span class="hljs-comment">// 还可以加一些其他信息的判断，比如用户账号已停用等判断</span>        <span class="hljs-keyword">if</span> (userInfo.getStatus().equals(<span class="hljs-string">"PROHIBIT"</span>))&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedException(<span class="hljs-string">"该用户已被冻结"</span>);        &#125;        <span class="hljs-comment">// 角色集合</span>        Set&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">// 查询用户角色</span>        <span class="hljs-comment">//一张表储存了用户id和他的所拥有的权限的id，另一张表储存了对应权限id的权限名。</span>        <span class="hljs-comment">//所以查出来是一列权限实体类</span>               List&lt;SysRoleEntity&gt; sysRoleEntityList = sysUserService.selectSysRoleByUserId(userInfo.getUserId());        <span class="hljs-keyword">for</span> (SysRoleEntity sysRoleEntity: sysRoleEntityList)&#123;            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_"</span> + sysRoleEntity.getRoleName()));        &#125;        userInfo.setAuthorities(authorities);        <span class="hljs-comment">// 进行登录</span>        <span class="hljs-comment">//上方所说的轮询并检测是否成功的标志就是看返回的是不是为null,不为null则表明认证成功。</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(userInfo, password, authorities);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="查询用户是否存在-selfuserdetailsservice"><a class="markdownIt-Anchor" href="#查询用户是否存在-selfuserdetailsservice"></a> 查询用户是否存在 SelfUserDetailsService</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SysUserService sysUserService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/9/13 17:23</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  username  用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@Return</span> UserDetails SpringSecurity用户信息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SelfUserEntity <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        <span class="hljs-comment">// 查询用户信息</span>        SysUserEntity sysUserEntity =sysUserService.selectUserByName(username);        <span class="hljs-keyword">if</span> (sysUserEntity!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 组装参数</span>            SelfUserEntity selfUserEntity = <span class="hljs-keyword">new</span> SelfUserEntity();            BeanUtils.copyProperties(sysUserEntity,selfUserEntity);            <span class="hljs-keyword">return</span> selfUserEntity;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><h3 id="符合security标准的用户类-selfuserentity"><a class="markdownIt-Anchor" href="#符合security标准的用户类-selfuserentity"></a> 符合Security标准的用户类 SelfUserEntity</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfUserEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">UserDetails</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用户ID</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Long userId;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用户名</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String username;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 密码</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String password;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 状态:NORMAL正常  PROHIBIT禁用</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String status;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用户角色</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Collection&lt;GrantedAuthority&gt; authorities;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 账户是否过期</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAccountNonExpired = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 账户是否被锁定</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAccountNonLocked = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 证书是否过期</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isCredentialsNonExpired = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 账户是否有效</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnabled = <span class="hljs-keyword">true</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;GrantedAuthority&gt; <span class="hljs-title">getAuthorities</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> authorities;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> isAccountNonExpired;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> isAccountNonLocked;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> isCredentialsNonExpired;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> isEnabled;&#125;&#125;</code></pre></div><h3 id="登录成功处理类-userloginsuccesshandler"><a class="markdownIt-Anchor" href="#登录成功处理类-userloginsuccesshandler"></a> 登录成功处理类 UserLoginSuccessHandler</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserLoginSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录成功返回结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/10/3 9:27</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span></span>&#123;        <span class="hljs-comment">// 组装JWT</span>        <span class="hljs-comment">//在认证处理器部分，将userinfo传入给UsernamePasswordAuthenticationToken作为principal</span>        SelfUserEntity selfUserEntity =  (SelfUserEntity) authentication.getPrincipal();        String token = JWTTokenUtil.createAccessToken(selfUserEntity);        log.info(selfUserEntity.toString());        token = JWTConfig.tokenPrefix + token;        <span class="hljs-comment">// 封装返回参数</span>        Map&lt;String,Object&gt; resultData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        resultData.put(<span class="hljs-string">"code"</span>,<span class="hljs-string">"200"</span>);        resultData.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"登录成功"</span>);        resultData.put(<span class="hljs-string">"token"</span>,token);        ResultUtil.responseJson(response,resultData);    &#125;&#125;</code></pre></div><h3 id="与jwt有关的工具类-jwttokenutil"><a class="markdownIt-Anchor" href="#与jwt有关的工具类-jwttokenutil"></a> 与JWT有关的工具类 JWTTokenUtil</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTTokenUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 私有化构造器</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">JWTTokenUtil</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成Token</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/10/2 12:16</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  selfUserEntity 用户安全实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@Return</span> Token</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createAccessToken</span><span class="hljs-params">(SelfUserEntity selfUserEntity)</span></span>&#123;        <span class="hljs-comment">// 登陆成功生成JWT</span>        String token = Jwts.builder()                <span class="hljs-comment">// 放入用户名和用户ID</span>                .setId(selfUserEntity.getUserId()+<span class="hljs-string">""</span>)                <span class="hljs-comment">// 主题</span>                .setSubject(selfUserEntity.getUsername())                <span class="hljs-comment">// 签发时间</span>                .setIssuedAt(<span class="hljs-keyword">new</span> Date())                <span class="hljs-comment">// 签发者</span>                .setIssuer(<span class="hljs-string">"sans"</span>)                <span class="hljs-comment">// 自定义属性 放入用户拥有权限</span>            <span class="hljs-comment">//重申一遍，多角色的时候，这个属性长[&#123;"authority":"ROLE_USER"&#125;,&#123;"authority":"ROLE_ADMIN"&#125;]这样，表明他有两个角色</span>                .claim(<span class="hljs-string">"authorities"</span>, JSON.toJSONString(selfUserEntity.getAuthorities()))                <span class="hljs-comment">// 失效时间</span>                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + JWTConfig.expiration))                <span class="hljs-comment">// 签名算法和密钥</span>                .signWith(SignatureAlgorithm.HS512, JWTConfig.secret)                .compact();        log.info(JSON.toJSONString(selfUserEntity.getAuthorities()));        <span class="hljs-keyword">return</span> token;    &#125;&#125;</code></pre></div><h2 id="5-jwt数据库-鉴权部分"><a class="markdownIt-Anchor" href="#5-jwt数据库-鉴权部分"></a> 5、JWT+数据库 鉴权部分</h2><p>上图</p><img src="/img/image-20200629141557755.png" srcset="/img/loading.gif" alt="image-20200629141557755" style="zoom:80%;" /><p>用到的类</p><h3 id="haspermission-鉴权类-userpermissionevaluator"><a class="markdownIt-Anchor" href="#haspermission-鉴权类-userpermissionevaluator"></a> hasPermission 鉴权类 UserPermissionEvaluator</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPermissionEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PermissionEvaluator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SysUserService sysUserService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * hasPermission鉴权方法</span><span class="hljs-comment">     * 这里仅仅判断PreAuthorize注解中的权限表达式</span><span class="hljs-comment">     * 实际中可以根据业务需求设计数据库通过targetUrl和permission做更复杂鉴权</span><span class="hljs-comment">     * 当然targetUrl不一定是URL可以是数据Id还可以是管理员标识等,这里根据需求自行设计</span><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> Sans</span><span class="hljs-comment">     * <span class="hljs-doctag">@CreateTime</span> 2019/10/6 18:25</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  authentication  用户身份(在使用hasPermission表达式时Authentication参数默认会自动带上)</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  targetUrl  请求路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>  permission 请求路径权限</span><span class="hljs-comment">     * <span class="hljs-doctag">@Return</span> boolean 是否通过</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-comment">//传入用户安全信息、目标url、需要的权限</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Object targetUrl, Object permission)</span> </span>&#123;        <span class="hljs-comment">// 获取用户信息</span>        SelfUserEntity selfUserEntity =(SelfUserEntity) authentication.getPrincipal();        Collection&lt;GrantedAuthority&gt; authorities = selfUserEntity.getAuthorities();        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;            log.info(authority.getAuthority());        &#125;        <span class="hljs-comment">// 查询用户权限(这里可以将权限放入缓存中提升效率)</span>        Set&lt;String&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">//role，权限表，表示有什么权限</span>        <span class="hljs-comment">//menu，功能表，表示能做什么</span>        <span class="hljs-comment">//role_menu表，表示什么权限能做什么事情</span>        <span class="hljs-comment">//user，用户表，表示你是谁</span>        <span class="hljs-comment">//user_role表，表示你有什么权限</span>        <span class="hljs-comment">//          SELECT DISTINCT m.* FROM sys_user_role ur</span>        <span class="hljs-comment">//LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id</span>        <span class="hljs-comment">//LEFT JOIN sys_menu m ON rm.menu_id = m.menu_id</span>        <span class="hljs-comment">//    WHERE ur.user_id = #&#123;userId&#125;</span>        <span class="hljs-comment">//通过用户的id，查询他能干什么。</span>        List&lt;SysMenuEntity&gt; sysMenuEntityList = sysUserService.selectSysMenuByUserId(selfUserEntity.getUserId());        <span class="hljs-keyword">for</span> (SysMenuEntity sysMenuEntity:sysMenuEntityList) &#123;            permissions.add(sysMenuEntity.getPermission());        &#125;        <span class="hljs-comment">// 权限对比</span>        <span class="hljs-keyword">if</span> (permissions.contains(permission.toString()))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(Authentication authentication, Serializable targetId, String targetType, Object permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p><strong>详细代码与注释</strong>：<a href="https://gitee.com/gukkibokou/spring-boot-security-demo" target="_blank" rel="noopener">Gitee</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaWeb开发</tag>
      
      <tag>SpringSecurity</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博创4412开发板移植最新的ssh</title>
    <link href="/p/4119c141.html"/>
    <url>/p/4119c141.html</url>
    
    <content type="html"><![CDATA[<p>和缺少资料的开发板斗智斗勇的过程之其三</p><a id="more"></a><h4 id="平台"><a class="markdownIt-Anchor" href="#平台"></a> 平台</h4><ol><li>UP-Tech 4412</li><li>Kubuntu 64位</li></ol><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><ol><li>串口的缺点实在是让人难以忍受</li></ol><h4 id="工具和软件"><a class="markdownIt-Anchor" href="#工具和软件"></a> 工具和软件</h4><ol><li>2009q3的交叉编译工具</li><li><a href="https://www.openssl.org/source/openssl-1.1.1e.tar.gz" target="_blank" rel="noopener">OpenSSL-1.1.1e</a></li><li><a href="ftp://mirror.internode.on.net/pub/OpenBSD/OpenSSH/portable/openssh-8.2p1.tar.gz">OpenSSH-8.2p1</a></li><li><a href="http://www.zlib.net/zlib-1.2.11.tar.gz" target="_blank" rel="noopener">zlib-1.2.11</a></li></ol><h4 id="移植过程"><a class="markdownIt-Anchor" href="#移植过程"></a> 移植过程</h4><h5 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h5><p>​先从他们各自的官网上下下来源代码。为了确保工作目录的干净，我将源码都保存在一个叫做<strong>Source_Code</strong>的目录下，并且事先创建好<strong>Cross</strong>这个目录，用于保存编译好的库和文件。</p><h5 id="编译zlib"><a class="markdownIt-Anchor" href="#编译zlib"></a> 编译zlib</h5><p>​进入zlib的源代码目录，执行<code>./configure --prefix=/home/gukki/Cross_Code/Cross/zlib</code>进行对<code>install</code>目录的指定以及<code>Makefile</code>的生成。</p><p>​对<code>Makefile</code>进行修改：</p><blockquote><p>在开头加入<code>CROSS=arm-none-linux-gnueabi-</code></p><p>将<code>CC=gcc</code> 修改为<code>CC=$(CROSS)gcc</code></p><p>将<code>LDSHARED=gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map</code> 修改为</p><p><code>$(CROSS)gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map</code></p><p>将<code>CPP=gcc -E</code> 修改为 <code>CPP=$(CROSS)gcc -E</code></p><p>将<code>AR=ar</code>修改为 <code>AR=$(CROSS)ar</code></p></blockquote><p>如下图所示：</p><p><img src="/../img/image-20200326180038383.png" srcset="/img/loading.gif" alt="image-20200326180038383" /></p><p>保存并退出之后执行<code>make &amp;&amp; make install</code>，这样的话就将编译好的zlib安装到<strong>Cross</strong>目录下的<strong>zlib</strong>。</p><h5 id="编译openssl"><a class="markdownIt-Anchor" href="#编译openssl"></a> 编译openssl</h5><p>​进入openssl的源代码目录，执行</p><div class="hljs"><pre><code class="hljs shell">./Configure linux-armv4 no-asm shared --prefix=/home/gukki/Cross_Code CROSS_COMPILE=/home/gukki/baidunetdiskdownload/arm-2009q3/bin/arm-none-linux-gnueabi- CC=gcc</code></pre></div><p>其中：</p><p>​<code>linux-armv4</code>指定了目标平台</p><p>​<code>no-asm</code>表明不生成汇编代码加速</p><p>​<code>shared</code> 表明生成动态链接库</p><p>​<code>prefix</code>指定了安装目录</p><p>​<code>CROSS_COMPILE</code>使用绝对路径制定了交叉编译器的目录。</p><p>​<code>CC</code> 指定了使用gcc</p><p>执行<code>make &amp;&amp; make install</code>，将编译好的库安装到了预先指定好的目录了。</p><h5 id="编译openssh"><a class="markdownIt-Anchor" href="#编译openssh"></a> 编译openssh</h5><p>​进入openssh的源代码目录，执行</p><div class="hljs"><pre><code class="hljs shell">./configure --host=arm-none-linux-gnueabi --with-libs --with-zlib=/home/gukki/Cross_Code/Cross/zlib --with-ssl-dir=/home/gukki/Cross_Code/Cross/openssl1.1.1 --disable-etc-default-login CC=arm-none-linux-gnueabi-gcc AR=arm-none-linux-gnueabi-ar</code></pre></div><p>这个就不用多说了，都是指定之前编译好的库的所在地以及交叉编译器。</p><p>​执行<code>make</code> ，不要执行<code>make install</code>，否则他会将你生成的程序安装到主机上。</p><p>​生成结束之后，我是用了网上的一个大佬的脚本，一键打包好所有东西，生成<code>usr.tar.bz2</code>。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>file_a="scp sftp ssh ssh-add ssh-agent ssh-keygen ssh-keyscan" file_b="moduli ssh_config sshd_config" file_c="sftp-server ssh-keysign"key="ssh_host_rsa_key ssh_host_dsa_key ssh_host_ecdsa_key ssh_host_ed25519_key"  mkdir -p usr/local/bin usr/local/etc usr/libexec mkdir usr/sbin/ for i in $file_adoif [ -f $i ];thencp $i usr/local/bin/echo "cp $i ok" elseecho "error:$i not exist "        exit_script  fidone for i in $file_bdoif [ -f $i ];thencp $i usr/local/etc/echo "cp $i ok"elseecho "error:$i not exist"exit_script fidone for i in $file_cdo    if [ -f $i ];then        cp $i usr/libexec        echo "cp $i ok"    else        echo "error:$i not exist"        exit_script    fidone if [ -f "sshd" ];thencp sshd usr/sbin/echo "cp sshd ok"elseecho "error:sshd not exist"exit_scriptfi <span class="hljs-meta">#</span><span class="bash"> ssh_host_rsa_key</span>if [ -f "ssh_host_rsa_key" ];thenecho "ssh_host_rsa_key exist"cp ssh_host_rsa_key usr/local/etc/echo "cp ssh_host_rsa_key ok" elsessh-keygen -t rsa -f ssh_host_rsa_key -N ""cp ssh_host_rsa_key usr/local/etc/echo "cp ssh_host_rsa_key ok" fi <span class="hljs-meta">#</span><span class="bash"> ssh_host_dsa_key</span>if [ -f "ssh_host_dsa_key" ];thenecho "ssh_host_dsa_key exist"cp ssh_host_dsa_key usr/local/etc/echo "cp ssh_host_dsa_key ok" elsessh-keygen -t dsa -f ssh_host_dsa_key -N ""cp ssh_host_dsa_key usr/local/etc/echo "cp ssh_host_dsa_key ok" fi <span class="hljs-meta">#</span><span class="bash"> ssh_host_ecdsa_key</span>if [ -f "ssh_host_ecdsa_key" ];thenecho "ssh_host_ecdsa_key exist"cp ssh_host_ecdsa_key usr/local/etc/echo "cp ssh_host_ecdsa_key ok" elsessh-keygen -t ecdsa -f ssh_host_ecdsa_key -N ""cp ssh_host_ecdsa_key usr/local/etc/echo "cp ssh_host_ecdsa_key ok" fi <span class="hljs-meta">#</span><span class="bash"> ssh_host_ed25519_key</span>if [ -f "ssh_host_ed25519_key" ];thenecho "ssh_host_ed25519_key exist"chmod 600 ssh_host_ed25519_keycp ssh_host_ed25519_key usr/local/etc/echo "cp ssh_host_ed25519_key ok" elsessh-keygen -t dsa -f ssh_host_ed25519_key -N ""chmod 600 ssh_host_ed25519_keycp ssh_host_ed25519_key usr/local/etc/echo "cp ssh_host_ed25519_key ok" fi tar -cjvf usr.tar.bz2 usr/*echo "pack usr to usr.tar.bz2 ok"</code></pre></div><p>以上，在宿主机上的操作结束了。接下来是在开发板上的操作。</p><h5 id="开发板上的操作"><a class="markdownIt-Anchor" href="#开发板上的操作"></a> 开发板上的操作</h5><p>​将打包好的<code>usr.tar.bz2</code>解压到开发板的根目录，并尝试执行<code>/usr/sbin/sshd</code>来启动ssh服务，可能会出现缺少动态链接库的情况，可以从宿主机上复制过来。其中<code>libcrypto</code>存在于openssl的源代码目录下面，<code>libz</code>存在于zlib的源代码目录中。<code>libcrypto</code>可直接复制到开发板的<code>/lib</code>目录下，而<code>libz</code>则需要建立软连接：<code>ln -s /lib/libz.so.1.2.11 /lib/libz.so.1</code></p><p>​然后进行如下配置</p><blockquote><p>ssh的配置文件进行修改，以允许<code>root</code>登录：修改 <code>/usr/local/etc/ssh_config</code>，将<code>PermitRootLogin yes</code>前面的注释去掉，如果没有这句，就打进去吧。</p><p>修改<code>/etc/passwd</code>,增加以下三句</p><blockquote><p>root: x :1000:1000:root:/root:/bin/sh<br />root : x :0:Linux User,:/home/root:/bin/sh</p><p>sshd: x :74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</p></blockquote><p>x旁边的两空格要删除掉，我这个编辑器会把他们显示为❌… 这两句话是为了修改<code>root</code>密码的时候出现<code>unknown uid 0</code>的情况</p><p>执行</p><div class="hljs"><pre><code class="hljs shell">mkdir /var/empty/sshd/etc -pcd /var/empty/sshd/etcln -s /etc/localtime localtime</code></pre></div><p>防止出现<code>Missing privilege separation directory: /var/empty/</code>这个错误</p></blockquote><p>​好了，现在你可以对<code>root</code>密码进行修改，并启动ssh了。</p><p>​为了可以开机启动ssh服务，需要在<code>/etc/init.d/rcS</code>的最后面加上<code>/usr/sbin/sshd &amp;</code></p><p>​- wan</p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>软件移植</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Coding和Github上进行双线自动化部署Hexo</title>
    <link href="/p/52f9e600.html"/>
    <url>/p/52f9e600.html</url>
    
    <content type="html"><![CDATA[<p>如何在国内和国外自动化搭建静态博客</p><a id="more"></a><h3 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h3><p>​我前几天开始搭建这个博客，由于之前搭建过很多次，所以没有出现什么意外就搭建完了。但是当我把博客地址给其他人的时候，他们有的反应打得开，有的反应打不开。经过一番谷歌之后我发现原因可能是gitpage的服务器在国外，会出现加载失败的问题。与此同时我又了解到国内也有提供类似静态页面托管服务的厂家，我就想把博客也一并部署到国内的服务器上。我选择了可免费绑定域名的Coding（需要实名认证）。</p><p>​我这种经常宿舍实验室两头跑的人有在不同电脑上写博客的需求，而我又不想每次都要拷个源代码，于是便萌生了将博客源代码上传到github去的想法。但是这样一来每次写完代码都要做git三连和hexo三连，很是麻烦。一番搜索之后发现Appveyor可以实现自动化部署hexo，只需要推送到远程仓库，Appveyor就可以帮我自动部署了。</p><p>​但是对于coding的话，我用Appveyor就找不到什么好方法了。我们可以利用github自带的Ci来进行Coding的静态页面的自动化部署。当然你也可以不用Appveyor，直接利用github的Ci进行部署也是可以的。</p><h3 id="要求"><a class="markdownIt-Anchor" href="#要求"></a> 要求</h3><div class="hljs"><pre><code>- 一个域名- 一个github账户- 一个coding账户（需要实名认证）</code></pre></div><h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3><h4 id="1-新建仓库"><a class="markdownIt-Anchor" href="#1-新建仓库"></a> 1. 新建仓库</h4><p>​我们先新建一个公开的源码仓库，用于保存博客源代码。</p><h4 id="2-去appveyor注册"><a class="markdownIt-Anchor" href="#2-去appveyor注册"></a> 2. 去Appveyor注册</h4><p>​<a href="https://ci.appveyor.com/signup" target="_blank" rel="noopener">注册网址</a>，选择<strong>FREE-for open-source projects</strong> ,并选择使用github账户登录。</p><p><img src="/../img/image-20200223213407364.png" srcset="/img/loading.gif" alt="image-20200223213407364" /></p><h4 id="3-新建并加密一个access_token"><a class="markdownIt-Anchor" href="#3-新建并加密一个access_token"></a> 3. 新建并加密一个Access_Token</h4><p>​<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">申请地址</a>，这是用来申请一个Token，Appveyor就是利用这个来访问你的Github仓库的，我把权限全部给了。在最上面的Note一栏里面填入这个Token的名字，随意。</p><p>​<img src="/../img/image-20200223213834567.png" srcset="/img/loading.gif" alt="image-20200223213834567" /></p><p>​然后点击最下面的Generate token。复制好他给出的Token，它只会出现一次，如果你忘记了的话，只能删掉重新生成一个了。</p><p><img src="/../img/image-20200223213922721.png" srcset="/img/loading.gif" alt="image-20200223213922721" /></p><p>​因为这个仓库是公开的，而且这个Token是要放在这个仓库里面的，为了安全，我们需要对它进行加密。来到<a href="https://ci.appveyor.com/tools/encrypt" target="_blank" rel="noopener">Appveyor提供的加密页面</a>，输入刚才新建的Token，点击Encypt，即可生成加密后的Token。</p><h4 id="4-新建appveyor的配置文件"><a class="markdownIt-Anchor" href="#4-新建appveyor的配置文件"></a> 4. 新建Appveyor的配置文件</h4><p>​在博客源代码目录中新建一个<code>appveyor.yml</code>，你可以根据官方文档自行填写，也可仿照我的：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">clone_depth:</span> <span class="hljs-number">5</span><span class="hljs-attr">environment:</span>  <span class="hljs-attr">access_token:</span>    <span class="hljs-attr">secure:</span> <span class="hljs-string">填写你的加密后的Token</span><span class="hljs-attr">install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">node</span> <span class="hljs-string">--version</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">--version</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span><span class="hljs-attr">build_script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><span class="hljs-attr">artifacts:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">public</span><span class="hljs-attr">on_success:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">credential.helper</span> <span class="hljs-string">store</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">ps:</span> <span class="hljs-string">Add-Content</span> <span class="hljs-string">"$env:USERPROFILE\.git-credentials"</span> <span class="hljs-string">"https://$($env:access_token):x-oauth-basic@github.com`n"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">"%GIT_USER_EMAIL%"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">"%GIT_USER_NAME%"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">--depth</span> <span class="hljs-number">5</span> <span class="hljs-string">-q</span> <span class="hljs-string">--branch=%TARGET_BRANCH%</span> <span class="hljs-string">%STATIC_SITE_REPO%</span> <span class="hljs-string">%TEMP%\static-site</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">%TEMP%\static-site</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">del</span> <span class="hljs-string">*</span> <span class="hljs-string">/f</span> <span class="hljs-string">/q</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">for</span> <span class="hljs-string">/d</span> <span class="hljs-string">%%p</span> <span class="hljs-string">IN</span> <span class="hljs-string">(*)</span> <span class="hljs-string">do</span> <span class="hljs-string">rmdir</span> <span class="hljs-string">"%%p"</span> <span class="hljs-string">/s</span> <span class="hljs-string">/q</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">SETLOCAL</span> <span class="hljs-string">EnableDelayedExpansion</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">robocopy</span> <span class="hljs-string">"%APPVEYOR_BUILD_FOLDER%\public"</span> <span class="hljs-string">"%TEMP%\static-site"</span> <span class="hljs-string">/e</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">IF</span> <span class="hljs-type">!ERRORLEVEL</span><span class="hljs-string">!</span> <span class="hljs-string">EQU</span> <span class="hljs-number">1</span> <span class="hljs-string">(exit</span> <span class="hljs-number">0</span><span class="hljs-string">)</span> <span class="hljs-string">ELSE</span> <span class="hljs-string">(IF</span> <span class="hljs-type">!ERRORLEVEL</span><span class="hljs-string">!</span> <span class="hljs-string">EQU</span> <span class="hljs-number">3</span> <span class="hljs-string">(exit</span> <span class="hljs-number">0</span><span class="hljs-string">)</span> <span class="hljs-string">ELSE</span> <span class="hljs-string">(exit</span> <span class="hljs-number">1</span><span class="hljs-string">))</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">-A</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">"%APPVEYOR_REPO_BRANCH%"</span><span class="hljs-string">=="master"</span> <span class="hljs-string">if</span> <span class="hljs-string">not</span> <span class="hljs-string">defined</span> <span class="hljs-string">APPVEYOR_PULL_REQUEST_NUMBER</span> <span class="hljs-string">(git</span> <span class="hljs-string">diff</span> <span class="hljs-string">--quiet</span> <span class="hljs-string">--exit-code</span> <span class="hljs-string">--cached</span> <span class="hljs-string">||</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">"Update Static Site"</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> <span class="hljs-string">%TARGET_BRANCH%</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">appveyor</span> <span class="hljs-string">AddMessage</span> <span class="hljs-string">"Static Site Updated"</span><span class="hljs-string">)</span></code></pre></div><p>​其中<code>GIT_USER_EMAIL</code>,<code>GIT_USER_NAME</code>,<code>TARGET_BRANCH</code>,<code>STATIC_SITE_REPO</code>，他们分别是git的用邮箱、用户名、待部署仓库的目标分支，待部署的目标仓库（你的静态页面的github地址）。这几个都是要我们去Appveyor里面设置的环境变量。</p><h4 id="5-appveyor的配置"><a class="markdownIt-Anchor" href="#5-appveyor的配置"></a> 5. Appveyor的配置</h4><p>​回到Appveyor，点击New Project</p><p><img src="/../img/image-20200223214015897.png" srcset="/img/loading.gif" alt="image-20200223214015897" /></p><p>​选择github里面你的博客源代码目录，点击右侧的Add，在新页面选择setting</p><p><img src="/../img/image-20200223214102188.png" srcset="/img/loading.gif" alt="image-20200223214102188" /></p><p>​选择Environment，添加第四点所说的的环境变量</p><p>​<img src="/../img/image-20200223215652016.png" srcset="/img/loading.gif" alt="image-20200223215652016" /></p><p>​点击Save保存好配置。</p><p>​之后，你只要把你的博客源代码推送到远程仓库之后，Appveyor会自动检测到你的推送并进行自动化部署。类似这样：</p><p>​<img src="/../img/image-20200223220116830.png" srcset="/img/loading.gif" alt="image-20200223220116830" /></p><p>​并且可以再你的源代码仓库里面查看是否部署成功：</p><p><img src="/../img/image-20200223220259404.png" srcset="/img/loading.gif" alt="image-20200223220259404" /></p><p>​</p><h4 id="6-对coding进行自动部署"><a class="markdownIt-Anchor" href="#6-对coding进行自动部署"></a> 6. 对Coding进行自动部署</h4><p>​来到Coding的<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>，点击个人版登录，新建一个DevOps项目，建议项目名称跟你的用户名一致。在右侧的“构建与部署”处选择静态网站，选择立即发布静态网站，网站名称随意。</p><p>​然后进入到个人设置，点击访问令牌</p><p><img src="/../img/image-20200223221358546.png" srcset="/img/loading.gif" alt="image-20200223221358546" /></p><p>​这个类似于github的Access_Token,在这里我也是把权限全给了。</p><p>​创建完成后记住令牌和令牌用户名。回到github的博客源代码仓库，选择上方的Actions，这个也就是github的Ci，选择<strong>Set up a workflow yourself</strong></p><p><img src="/../img/image-20200223221848554.png" srcset="/img/loading.gif" alt="image-20200223221848554" /></p><p>​在出现的编辑窗口里面，用下面的文本替换掉里面的内容（知乎上的一个大佬的配置）</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">自动部署</span> <span class="hljs-string">Hexo</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">build:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">strategy:</span>      <span class="hljs-attr">matrix:</span>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">[10.x]</span>    <span class="hljs-attr">steps:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">开始运行</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">设置</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>        <span class="hljs-attr">with:</span>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">安装</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">CI</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>          <span class="hljs-string">export</span> <span class="hljs-string">TZ='Asia/Shanghai'</span>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">缓存</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>        <span class="hljs-attr">id:</span> <span class="hljs-string">cache-dependencies</span>        <span class="hljs-attr">with:</span>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles('**/package-lock.json')&#125;&#125;</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">安装插件</span>        <span class="hljs-attr">if:</span> <span class="hljs-string">steps.cache-dependencies.outputs.cache-hit</span> <span class="hljs-string">!=</span> <span class="hljs-string">'true'</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">部署博客</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>          <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span>          <span class="hljs-string">cd</span> <span class="hljs-string">./public</span>          <span class="hljs-string">git</span> <span class="hljs-string">init</span>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.name</span> <span class="hljs-string">"$<span class="hljs-template-variable">&#123;&#123;secrets.GIT_NAME&#125;&#125;</span>"</span>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">user.email</span> <span class="hljs-string">"$<span class="hljs-template-variable">&#123;&#123;secrets.GIT_EMAIL&#125;&#125;</span>"</span>          <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">.</span>          <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">"Update"</span>          <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">--force</span> <span class="hljs-string">--quiet</span> <span class="hljs-string">"https://$<span class="hljs-template-variable">&#123;&#123;secrets.CD_TOKEN&#125;&#125;</span>@$<span class="hljs-template-variable">&#123;&#123;secrets.CD_REF&#125;&#125;</span>"</span> <span class="hljs-string">master:master</span></code></pre></div><p>​其中，以<code>secrets.</code>开头的四个变量是需要我们去设置的环境变量。 点击右边的Start commit保存。</p><p>​我们进入源码仓库的环境变量设置，其位置如下：</p><p>​<img src="/../img/image-20200223222546211.png" srcset="/img/loading.gif" alt="image-20200223222546211" /></p><p>​这四个变量的意思分别如下表所示：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">意思</th></tr></thead><tbody><tr><td style="text-align:center">GIT_NAME</td><td style="text-align:center">git的用户名</td></tr><tr><td style="text-align:center">GIT_EMAIL</td><td style="text-align:center">git的邮箱</td></tr><tr><td style="text-align:center">CD_REF</td><td style="text-align:center">coding的静态页面的仓库地址</td></tr><tr><td style="text-align:center">CD_TOKEN</td><td style="text-align:center">coding的令牌用户名:coding的令牌</td></tr></tbody></table><p>其中CD_REF在你的Coding的右上方可以看到，改成ssh之后@后面的就是CD_REF了。</p><p><img src="/../img/image-20200223223844299.png" srcset="/img/loading.gif" alt="image-20200223223844299" /></p><p>以后我们每次写完文章，直接git三连就可以自动化部署到两个静态页面托管仓库了。</p><h4 id="7-域名绑定"><a class="markdownIt-Anchor" href="#7-域名绑定"></a> 7. 域名绑定</h4><p>​我们可以对域名的dns解析记录进行修改，实现国内用户访问的是coding上的页面，国外用户访问github上的页面。</p><p>​一图流：</p><p>​<img src="/../img/image-20200223225143011.png" srcset="/img/loading.gif" alt="image-20200223225143011" /></p><p>​如果你的coding站点无法申请到证书，请暂停下境外的解析。</p><p>​-完</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>没有用的知识</tag>
      
      <tag>自动化部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于4412的opencv的移植(附带contrib)</title>
    <link href="/p/42ae8816.html"/>
    <url>/p/42ae8816.html</url>
    
    <content type="html"><![CDATA[<p>和缺少资料的开发板斗智斗勇的过程之其一</p><a id="more"></a><h4 id="平台"><a class="markdownIt-Anchor" href="#平台"></a> 平台</h4><ol><li>UP-Tech 4412</li><li>Kubuntu 18.04LTS 64位</li></ol><h4 id="使用的工具"><a class="markdownIt-Anchor" href="#使用的工具"></a> 使用的工具</h4><ol><li>2013版的交叉编译工具(arm-2013.05-24-arm-none-linux-gnueabi)</li><li>opencv_3.4.9</li><li>opencv_contrib_3.4.9</li><li>cmake-gui</li></ol><h4 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h4><ol><li>放假之前用的虚拟机被我删除了，里面的文件都没了。</li><li>开发板的文件系统被我折腾坏了</li><li>需要重新移植opencv</li></ol><h4 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程：</h4><h5 id="1-下载所需软件以及源代码"><a class="markdownIt-Anchor" href="#1-下载所需软件以及源代码"></a> 1. 下载所需软件以及源代码</h5><p>​首先下载好我们需要使用到的各个文件，他们的下载链接如下所示：</p><div class="hljs"><pre><code class="hljs perl">arm-<span class="hljs-number">2013.05</span>-<span class="hljs-number">24</span>-arm-none-linux-gnueabi链接：http:<span class="hljs-regexp">//pan</span>.baidu.com/<span class="hljs-keyword">s</span>/<span class="hljs-number">1</span>i3gNttFopencv_3.<span class="hljs-number">4.9</span>链接：https:<span class="hljs-regexp">//github</span>.com/opencv/opencv/archive/<span class="hljs-number">3.4</span>.<span class="hljs-number">9</span>.tar.gzopencv_contrib_3.<span class="hljs-number">4.9</span> 链接：https:<span class="hljs-regexp">//github</span>.com/opencv/opencv_contrib/archive/<span class="hljs-number">3.4</span>.<span class="hljs-number">9</span>.tar.gz</code></pre></div><p>至于cmake-gui的话，如果你使用的是ububtu，直接在终端输入<code>sudo apt install cmake-gui</code>即可。</p><p>将交叉编译器解压好，这里我的是<code>/home/gukki/baidunetdiskdownload/arm-2013.05/</code></p><p>将下载并解压好的两份源代码放在同一个目录。</p><h5 id="2-使用cmake-gui进行交叉编译"><a class="markdownIt-Anchor" href="#2-使用cmake-gui进行交叉编译"></a> 2. 使用cmake-gui进行交叉编译</h5><p>​打开cmake，如下图所示：（只截取了上半部分）</p><p><img src="/../img/image-20200220202805847.png" srcset="/img/loading.gif" alt="image-20200220202805847" /></p><p>​第一行是要求你输入你的opencv的源代码的绝对路径，在这里我的路径是<code>/home/gukki/OpenCv/Source_Code/opencv-3.4.9</code>，第二行要求你填写配置好的源代码的保存路径。在这里，我的是<code>/home/gukki/OpenCv/Process_Code</code>。</p><p>​填写完毕之后点击<code>Configure</code>，cmake要求你选择编译工具，由于我们是交叉编译，我们选择最后一项。点击下一步之后如下图所示：</p><p><img src="/../img/image-20200220203339941.png" srcset="/img/loading.gif" alt="image-20200220203339941" /></p><p>​其中<code>Operating System</code>顾名思义，操作系统，我们的开发板上用的是Linux，就写上吧。</p><p><code>C</code>要求你指定好交叉编译器的C编译器，也就是arm-gcc的所在地。</p><p><code>C++</code>同理，也是要求你填上arm-g++的所在地，而<code>Target Root</code>填写上你交叉编译器的目录。</p><p>​填写完成之后点击完成。</p><p>​配置完成之后应该会是一片红色，并且左下角的文本显示区域有一句<code>Configuring done</code>。</p><p>我们对我们的需求进行对opencv的裁剪：</p><blockquote><p>在搜索栏区域输入JPEG,勾选上<code>BUILD_JPEG</code></p><p>输入PNG,勾选上<code>BULID_PNG</code></p><p>输入nonfree，勾选上</p><p>输入gtk，取消勾选，因为我们用不上图形界面</p><p>输入zlib，勾选上</p><p>输入extra，在<code>Value</code>一栏上点击右边的三个点，定位好你的<code>opencv_contrib</code>的<code>moudules</code>文件夹。</p><p>输入prefix，输入你想安装到的文件夹路径。等会<code>make install</code>时会安装到这里。</p></blockquote><p>​配置完成之后点击<code>Configure</code>，此时你应该要下载一些有关附加模块的一些文件，可能需要很久，等不及的就不去配置extra。下载完成之后，可以再次对额外模块进行裁剪，根据你的需求来定。裁剪完成之后，再次点击<code>Configure</code>，应该不会出现红色了。</p><p>点击<code>Generate</code>生成工程文件。</p><h5 id="3编译文件"><a class="markdownIt-Anchor" href="#3编译文件"></a> 3.编译文件</h5><p>​进入你的配置好的源代码的文件夹，在此处打开终端，输入<code>make</code>开始编译，根据自身虚拟机配置情况，可在后面加上<code>-j 线程数</code>这个参数，我给虚拟机分配了8个核心，所以我编译速度比较快，只用了5分钟左右。如果你什么都没加，预计时间可能是半小时到一小时左右。中间可能有些警告，无须理会。只要没停下来就好。</p><p><img src="/../img/image-20200220210124846.png" srcset="/img/loading.gif" alt="image-20200220210124846" /></p><p>可以看到处理器是被吃满的。</p><p>​编译完成后输入<code>make install</code>，可能需要你加个<code>sudo</code>什么的…</p><p>​安装完成之后可以去设定的<code>prefix</code>文件夹去看看。应该长这样：</p><p><img src="/../img/image-20200220210712344.png" srcset="/img/loading.gif" alt="image-20200220210712344" /></p><p>​其中<code>lib</code>里面是我们编译好的库文件，使用<code>file</code>命令查看类型：</p><p><img src="/../img/image-20200220210841342.png" srcset="/img/loading.gif" alt="image-20200220210841342" /></p><p>​成功了大半了！</p><h5 id="4-移植到开发板上"><a class="markdownIt-Anchor" href="#4-移植到开发板上"></a> 4. 移植到开发板上</h5><p>​将<code>lib</code>文件夹里面的所有文件全部传到开发板的<code>/lib</code>，目录下面，使用<code>nfs</code>速度会快很多。</p><p>​由于我们使用了较新版本的<code>arm_gcc</code>编译工具链，我们还需要把交叉编译工具链里面的<code>libstdc++.so,libstdc++.so.6,libstdc++6.0.17</code>一起复制过去并覆盖。他们位于<code>arm-2013.05/arm-none-linux-gnueabi/libc/usr/lib/</code>这个地方。</p><h5 id="5-虚拟机编译设置"><a class="markdownIt-Anchor" href="#5-虚拟机编译设置"></a> 5. 虚拟机编译设置</h5><p>​为了让虚拟机知道opecv的头文件和库文件的位置，我们需要借助一个叫做<code>pkg-config</code> 的软件， 安装也是可以用<code>apt</code>来安装的。我们找到opencv库文件夹里面的pkgconfig文件夹，打开你的shell的配置文件，我使用的是<code>zsh</code>所以打开<code>.zshrc</code>加入以下的两句话句话：</p><div class="hljs"><pre><code class="hljs crystal">PKG_CONFIG_PATH=<span class="hljs-regexp">/home/gukki</span><span class="hljs-regexp">/OpenCv/</span>_Install/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">pkgconfig</span>/:$<span class="hljs-title">PKG_CONFIG_PATH</span></span>export PKG_CONFIG_PATH</code></pre></div><p>​自行替换你的pkgconfig文件夹位置。</p><p>​使用<code>source</code>命令让更改生效，输入<code>pkg-config --cflags --libs opencv</code>，应该会出现一大坨东西，如下所示：</p><p><img src="/../img/image-20200220212101215.png" srcset="/img/loading.gif" alt="image-20200220212101215" /></p><h5 id="6-测试与简化"><a class="markdownIt-Anchor" href="#6-测试与简化"></a> 6. 测试与简化</h5><p>​写一个非常简单的程序，来测试下吧：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Mat m;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>​保存为<code>T.cpp</code>，使用如下命令进行编译：</p><div class="hljs"><pre><code class="hljs shell">arm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` T.cpp -lpthread -lrt -ldl</code></pre></div><p>​应该只有一个警告，不需要理会。</p><p>​生成的<code>a.out</code>文件拷贝到开发板，给予权限。运行之后应该什么效果都没有，也没有任何报错。那就是行了。你可以试试更加复杂的程序了。但是不能有任何跟界面有关的函数出现比如<code>imshow</code>，<code>waitkey</code>等等，否则会报错。（因为我裁剪掉了）你也可以自行尝试如何让他们使用，有更好的想法可以告诉我！</p><p>​每次编译都要打那么长的代码，有没有方法可以简化？</p><p>​可以使用<code>alias</code>命令来进行简化，我的就是：</p><div class="hljs"><pre><code class="hljs shell">alias armcv="arm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` -lpthread -ldl -lrt"</code></pre></div><p>​同样的，写到你自己的shell的配置文件里面。</p><p>​完-</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>软件移植</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4412的wifi驱动以及管理软件的移植</title>
    <link href="/p/15bec6d.html"/>
    <url>/p/15bec6d.html</url>
    
    <content type="html"><![CDATA[<p>和资料错误的开发板斗智斗勇的过程之其二</p><a id="more"></a><h4 id="平台"><a class="markdownIt-Anchor" href="#平台"></a> 平台</h4><ol><li>UP-Tech 4412</li><li>Kubuntu 64位</li></ol><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><ol><li><p>给的pdf上面的wifi模块的型号不对</p><blockquote><p>它给我的是<strong>rt8723bu</strong>这个型号的驱动，实际上开发板上搭载的是<img src="/../img/image-20200219235946818.png" srcset="/img/loading.gif" alt="image-20200219235946818" /></p><p>这个型号的驱动</p></blockquote></li><li><p>由于缺少<code>wpa_supplicant</code>这个管理软件，wifi无法连接到加密的网络</p></li></ol><h4 id="解决过程"><a class="markdownIt-Anchor" href="#解决过程"></a> 解决过程</h4><p>​我仔细地查看开发板，发现开发板搭载的是<code>rtl8188eus</code>这个型号的无线模块。知道是什么型号的就好办了，直接开始移植吧。</p><p>​我先从google上找到了驱动源代码的<a href="https://github.com/quickreflex/rtl8188eus" target="_blank" rel="noopener">github</a>，clone下载之后，先对<code>Makefile</code>进行修改，由于它默认是i386平台，我们需要先对它进行屏蔽，并加入我们的设备。如下图所示：</p><p><img src="/../img/image-20200220001655792.png" srcset="/img/loading.gif" alt="image-20200220001655792" /></p><p><img src="/../img/image-20200220001636696.png" srcset="/img/loading.gif" alt="image-20200220001636696" /></p><p>其中<code>CONFIG_PLATFORM_ARM_Exynos4412=y</code>是我们新添加的设备。</p><p>​在1690行附近加入一段判断语句：</p><div class="hljs"><pre><code class="hljs shell">ifeq ($(CONFIG_PLATFORM_ARM_Exynos4412), y)                                   EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN                                   ARCH := arm                                                 CROSS_COMPILE := arm-none-linux-gnueabi-                                  KVER:=3.5.0                                                 KSRC :=/home/gukki/HostFiles/A9/SRC/kernel/linux-3.5.0-rc6/                         MODULE_NAME :=wlan                                             endif</code></pre></div><p>​注意<code>KVER</code>是你的内核版本号，<code>KSRC</code>是你的交叉编译好的内核目录。</p><p>​保存退出之后，直接<code>make</code>即可。生成的<code>wlan.ko</code>可通过minicom进行传输到开发板上，开发板上使用<code>insmod wlan.ko</code>来安装驱动。</p><p>​驱动安装完成之后使用<code>ifconfig -a</code>来进行查看自己的无线网卡的名字，并且使用<code>ifconfig 无线网卡名字 up</code>来进行启用网卡。</p><p>​驱动完成安装之后，运行<code>iwconfig</code>应该如下所示：</p><p><img src="/../img/image-20200220011149442.png" srcset="/img/loading.gif" alt="image-20200220011149442" /></p><hr /><p>​驱动安装完成之后，我发现这模块只能连接开放的wifi，进过一番google之后发现，我还需要移植一个名为<a href="https://w1.fi/releases/wpa_supplicant-0.7.2.tar.gz" target="_blank" rel="noopener"><strong>wpa_supplicant</strong></a>   的软件来进行管理。而这个软件又依赖于<a href="https://ftp.openssl.org/source/old/0.9.x/openssl-0.9.8e.tar.gz" target="_blank" rel="noopener"><strong>openssl</strong></a>这个库，索性一次全部搞定吧。</p><p>​这里我的wpa版本是0.7.2,ssl版本是0.9.8.e。先从网上把他们下载下来。我将他们都解压到一个文件夹里。openssl的移植需要wpa提供的补丁文件。</p><p>​执行命令:</p><p>​<code>cp wpa_supplicant-0.7.2/patches/openssl-0.9.8e-tls-extensions.patch ./openssl-0.9.8e</code></p><p>​<code>cd openssl-0.9.8e</code></p><p>​<code>patch -p1 &lt; openssl-0.9.8e-tls-extensions.patch</code></p><p>​创建一个干净的文件夹，我的路径是<code>/home/gukki/Cross_Code/Cross/openssl/</code>，在openssl-0.9.8目录里面运行<code>Configure</code>脚本来进行配置<code>Makefile</code>：</p><div class="hljs"><pre><code class="hljs shell">./Configure linux-elf-arm -DL_EDNIAN linux:'arm-none-linux-gnueabi-gcc' shared --prefix=/home/gukki/Cross_Code/Cross/openssl/ -lcrypto</code></pre></div><p>​配置完成之后就可以<code>make &amp;&amp; make install</code>了。生成的动态库文件在openssl/lib里面。</p><p>​接下来进行wpa的移植。</p><p>​进入wpa的源代码目录，修改<code>Makefile</code>文件，注释掉第一和第三行，并将CC改为你的交叉编译器，</p><p>在<br /><code>CFLAGS += -I../src</code><br /><code>CFLAGS += -I../src/utils</code><br />下添加：<br /><code>CFLAGS += -I/home/gukki/Cross_Code/Cross/openssl/include/</code></p><p>修改<br /><code>LIBS += -lssl</code><br />为<br /><code>LIBS += -lssl -L/home/gukki/Cross_Code/Cross/openssl/lib/</code></p><p>修改<br /><code>LIBS_p += -lcrypto</code><br />为<br /><code>LIBS_p += -lcrypto -L/home/gukki/Cross_Code/Cross/openssl/lib/</code></p><p>​保存并退出，将目录下面的<code>defconfig</code>复制为<code>.config</code>并执行<code>make</code></p><p>​编译完成之后，将目录下面的<code>wpa_supplicant</code>和<code>wpa_cli</code>文件拷贝到开发板的<code>/bin</code>目录下面。</p><hr /><p>​为了连接上加密的wifi，还需要在开发板的<code>/etc</code>目录下面添加wpa-psk-tkip.conf这一配置文件。</p><p>我的配置文件如下所示：</p><div class="hljs"><pre><code class="hljs routeros">WPA-PSK/TKIP       <span class="hljs-attribute">ctrl_interface</span>=/var/run/wpa_supplicant       network=&#123;       <span class="hljs-attribute">ssid</span>=<span class="hljs-string">"****"</span>       <span class="hljs-attribute">key_mgmt</span>=WPA-PSK       <span class="hljs-attribute">proto</span>=WPA RSN       <span class="hljs-attribute">pairwise</span>=CCMP       <span class="hljs-attribute">group</span>=CCMP       <span class="hljs-attribute">psk</span>=<span class="hljs-string">"***"</span>       &#125;</code></pre></div><p>​其中ssid是你的wifi名字，psk是你的密码。</p><p>​在开发板内创建wpa程序的运行目录：<code>mkdir /var/run/wpa_supplicant -p</code></p><p>​平时使用<code>wpa_supplicant -B -i wlan0 -c /etc/wpa-psk-tkip.conf</code>即可连接到wifi。</p><p>​连接到之后需要自己更改ip地址和默认网关。具体操作请自行搜索。</p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>驱动移植</tag>
      
      <tag>软件移植</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
