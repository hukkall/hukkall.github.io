[{"title":"博创4412开发板移植最新的ssh","url":"/2020/03/26/博创4412开发板移植最新的ssh/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位 \n\n#### 问题\n\n1. 串口的缺点实在是让人难以忍受\n\n#### 工具和软件\n\n1. 2009q3的交叉编译工具\n2. [OpenSSL-1.1.1e](https://www.openssl.org/source/openssl-1.1.1e.tar.gz)\n3. [OpenSSH-8.2p1](ftp://mirror.internode.on.net/pub/OpenBSD/OpenSSH/portable/openssh-8.2p1.tar.gz)\n4. [zlib-1.2.11](http://www.zlib.net/zlib-1.2.11.tar.gz)\n\n#### 移植过程\n\n##### 前期准备\n\n​\t先从他们各自的官网上下下来源代码。为了确保工作目录的干净，我将源码都保存在一个叫做**Source_Code**的目录下，并且事先创建好**Cross**这个目录，用于保存编译好的库和文件。\n\n##### 编译zlib\n\n​\t进入zlib的源代码目录，执行`./configure --prefix=/home/gukki/Cross_Code/Cross/zlib`进行对`install`目录的指定以及`Makefile`的生成。\n\n​\t对`Makefile`进行修改：\n\n> 在开头加入`CROSS=arm-none-linux-gnueabi-`\n>\n> 将`CC=gcc` 修改为`CC=$(CROSS)gcc`\n>\n> 将`LDSHARED=gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map` 修改为\n>\n> `$(CROSS)gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map`\n>\n> 将`CPP=gcc -E` 修改为 `CPP=$(CROSS)gcc -E`\n>\n> 将`AR=ar`修改为 `AR=$(CROSS)ar`\n\n如下图所示：\n\n![image-20200326180038383](/../img/image-20200326180038383.png)\n\n保存并退出之后执行`make && make install`，这样的话就将编译好的zlib安装到**Cross**目录下的**zlib**。\n\n##### 编译openssl\n\n​\t进入openssl的源代码目录，执行\n\n```shell\n./Configure linux-armv4 no-asm shared --prefix=/home/gukki/Cross_Code CROSS_COMPILE=/home/gukki/baidunetdiskdownload/arm-2009q3/bin/arm-none-linux-gnueabi- CC=gcc\n```\n\n其中：\n\n​\t`linux-armv4`指定了目标平台\n\n​\t`no-asm`表明不生成汇编代码加速\n\n​\t`shared` 表明生成动态链接库\n\n​\t`prefix`指定了安装目录\n\n​\t`CROSS_COMPILE`使用绝对路径制定了交叉编译器的目录。\n\n​\t`CC` 指定了使用gcc\n\n执行`make && make install`，将编译好的库安装到了预先指定好的目录了。\n\n##### 编译openssh\n\n​\t进入openssh的源代码目录，执行\n\n```shell\n./configure --host=arm-none-linux-gnueabi --with-libs --with-zlib=/home/gukki/Cross_Code/Cross/zlib --with-ssl-dir=/home/gukki/Cross_Code/Cross/openssl1.1.1 --disable-etc-default-login CC=arm-none-linux-gnueabi-gcc AR=arm-none-linux-gnueabi-ar\n```\n\n这个就不用多说了，都是指定之前编译好的库的所在地以及交叉编译器。\n\n​\t执行`make` ，不要执行`make install`，否则他会将你生成的程序安装到主机上。\n\n​\t生成结束之后，我是用了网上的一个大佬的脚本，一键打包好所有东西，生成`usr.tar.bz2`。\n\n``` shell\n#!/bin/bash\nfile_a=\"scp sftp ssh ssh-add ssh-agent ssh-keygen ssh-keyscan\" \nfile_b=\"moduli ssh_config sshd_config\" \nfile_c=\"sftp-server ssh-keysign\"\nkey=\"ssh_host_rsa_key ssh_host_dsa_key ssh_host_ecdsa_key ssh_host_ed25519_key\" \n \nmkdir -p usr/local/bin usr/local/etc usr/libexec \nmkdir usr/sbin/\n \nfor i in $file_a\ndo\n\tif [ -f $i ];then\n\t\tcp $i usr/local/bin/\n\t\techo \"cp $i ok\" \n\telse\n\t\techo \"error:$i not exist \"\n        exit_script  \n\tfi\ndone\n \nfor i in $file_b\ndo\n\tif [ -f $i ];then\n\t\tcp $i usr/local/etc/\n\t\techo \"cp $i ok\"\n\telse\n\t\techo \"error:$i not exist\"\n\t\texit_script\n \tfi\ndone\n \nfor i in $file_c\ndo\n    if [ -f $i ];then\n        cp $i usr/libexec\n        echo \"cp $i ok\"\n    else\n        echo \"error:$i not exist\"\n        exit_script\n    fi\ndone\n \nif [ -f \"sshd\" ];then\n\tcp sshd usr/sbin/\n\techo \"cp sshd ok\"\nelse\n\techo \"error:sshd not exist\"\n\texit_script\nfi\n \n# ssh_host_rsa_key\nif [ -f \"ssh_host_rsa_key\" ];then\n\techo \"ssh_host_rsa_key exist\"\n\tcp ssh_host_rsa_key usr/local/etc/\n\techo \"cp ssh_host_rsa_key ok\" \nelse\n\tssh-keygen -t rsa -f ssh_host_rsa_key -N \"\"\n\tcp ssh_host_rsa_key usr/local/etc/\n\techo \"cp ssh_host_rsa_key ok\" \nfi\n \n# ssh_host_dsa_key\nif [ -f \"ssh_host_dsa_key\" ];then\n\techo \"ssh_host_dsa_key exist\"\n\tcp ssh_host_dsa_key usr/local/etc/\n\techo \"cp ssh_host_dsa_key ok\" \nelse\n\tssh-keygen -t dsa -f ssh_host_dsa_key -N \"\"\n\tcp ssh_host_dsa_key usr/local/etc/\n\techo \"cp ssh_host_dsa_key ok\" \nfi\n \n# ssh_host_ecdsa_key\nif [ -f \"ssh_host_ecdsa_key\" ];then\n\techo \"ssh_host_ecdsa_key exist\"\n\tcp ssh_host_ecdsa_key usr/local/etc/\n\techo \"cp ssh_host_ecdsa_key ok\" \nelse\n\tssh-keygen -t ecdsa -f ssh_host_ecdsa_key -N \"\"\n\tcp ssh_host_ecdsa_key usr/local/etc/\n\techo \"cp ssh_host_ecdsa_key ok\" \nfi\n \n# ssh_host_ed25519_key\nif [ -f \"ssh_host_ed25519_key\" ];then\n\techo \"ssh_host_ed25519_key exist\"\n\tchmod 600 ssh_host_ed25519_key\n\tcp ssh_host_ed25519_key usr/local/etc/\n\techo \"cp ssh_host_ed25519_key ok\" \nelse\n\tssh-keygen -t dsa -f ssh_host_ed25519_key -N \"\"\n\tchmod 600 ssh_host_ed25519_key\n\tcp ssh_host_ed25519_key usr/local/etc/\n\techo \"cp ssh_host_ed25519_key ok\" \nfi\n \ntar -cjvf usr.tar.bz2 usr/*\necho \"pack usr to usr.tar.bz2 ok\"\n```\n\n以上，在宿主机上的操作结束了。接下来是在开发板上的操作。\n\n##### 开发板上的操作\n\n​\t将打包好的`usr.tar.bz2`解压到开发板的根目录，并尝试执行`/usr/sbin/sshd`来启动ssh服务，可能会出现缺少动态链接库的情况，可以从宿主机上复制过来。其中`libcrypto`存在于openssl的源代码目录下面，`libz`存在于zlib的源代码目录中。`libcrypto`可直接复制到开发板的`/lib`目录下，而`libz`则需要建立软连接：`ln -s /lib/libz.so.1.2.11  /lib/libz.so.1`\n\n​\t然后进行如下配置\n\n> ssh的配置文件进行修改，以允许`root`登录：修改 `/usr/local/etc/ssh_config`，将`PermitRootLogin yes`前面的注释去掉，如果没有这句，就打进去吧。\n>\n> 修改`/etc/passwd`,增加以下三句\n>\n> > root: x :1000:1000:root:/root:/bin/sh\n> > root : x :0:Linux User,,,:/home/root:/bin/sh\n> >\n> > sshd: x :74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\n>\n> x旁边的两空格要删除掉，我这个编辑器会把他们显示为:x:..... 这两句话是为了修改`root`密码的时候出现`unknown uid 0`的情况\n>\n> 执行\n>\n> ```shell\n> mkdir /var/empty/sshd/etc -p\n> cd /var/empty/sshd/etc\n> ln -s /etc/localtime localtime\n> ```\n>\n> 防止出现`Missing privilege separation directory: /var/empty/`这个错误\n\n​\t好了，现在你可以对`root`密码进行修改，并启动ssh了。\n\n​\t为了可以开机启动ssh服务，需要在`/etc/init.d/rcS`的最后面加上`/usr/sbin/sshd &`\n\n​\t- wan\n\n","tags":["嵌入式","软件移植"]},{"title":"在Coding和Github上进行双线自动化部署Hexo","url":"/2020/02/21/在Coding和Github上进行双线自动化部署Hexo/","content":"\n### 起因\n\n​\t\t我前几天开始搭建这个博客，由于之前搭建过很多次，所以没有出现什么意外就搭建完了。但是当我把博客地址给其他人的时候，他们有的反应打得开，有的反应打不开。经过一番谷歌之后我发现原因可能是gitpage的服务器在国外，会出现加载失败的问题。与此同时我又了解到国内也有提供类似静态页面托管服务的厂家，我就想把博客也一并部署到国内的服务器上。我选择了可免费绑定域名的Coding（需要实名认证）。  \n\n​\t\t我这种经常宿舍实验室两头跑的人有在不同电脑上写博客的需求，而我又不想每次都要拷个源代码，于是便萌生了将博客源代码上传到github去的想法。但是这样一来每次写完代码都要做git三连和hexo三连，很是麻烦。一番搜索之后发现Appveyor可以实现自动化部署hexo，只需要推送到远程仓库，Appveyor就可以帮我自动部署了。\n\n​\t\t但是对于coding的话，我用Appveyor就找不到什么好方法了。我们可以利用github自带的Ci来进行Coding的静态页面的自动化部署。当然你也可以不用Appveyor，直接利用github的Ci进行部署也是可以的。\n\n### 要求\n\n\t\t- 一个域名\n\t\t- 一个github账户\n\t\t- 一个coding账户（需要实名认证）\n\n### 过程\n\n#### 1. 新建仓库\n\n​\t\t我们先新建一个公开的源码仓库，用于保存博客源代码。\n\n#### 2. 去Appveyor注册\n\n​\t\t[注册网址](https://ci.appveyor.com/signup)，选择**FREE-for open-source projects** ,并选择使用github账户登录。\n\n![image-20200223213407364](/../img/image-20200223213407364.png)\n\n#### 3. 新建并加密一个Access_Token\n\n​\t\t[申请地址](https://github.com/settings/tokens/new)，这是用来申请一个Token，Appveyor就是利用这个来访问你的Github仓库的，我把权限全部给了。在最上面的Note一栏里面填入这个Token的名字，随意。\n\n​\t\t\t\t![image-20200223213834567](/../img/image-20200223213834567.png)\n\n​\t\t然后点击最下面的Generate token。复制好他给出的Token，它只会出现一次，如果你忘记了的话，只能删掉重新生成一个了。\n\n![image-20200223213922721](/../img/image-20200223213922721.png)\n\n​\t\t因为这个仓库是公开的，而且这个Token是要放在这个仓库里面的，为了安全，我们需要对它进行加密。来到[Appveyor提供的加密页面](https://ci.appveyor.com/tools/encrypt)，输入刚才新建的Token，点击Encypt，即可生成加密后的Token。\n\n#### 4. 新建Appveyor的配置文件\n\n​\t\t在博客源代码目录中新建一个`appveyor.yml`，你可以根据官方文档自行填写，也可仿照我的：\n\n```yaml\nclone_depth: 5\n\nenvironment:\n  access_token:\n    secure: 填写你的加密后的Token\n\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\n\nbuild_script:\n  - hexo generate\n\nartifacts:\n  - path: public\n\non_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n\n```\n\n​\t\t其中`GIT_USER_EMAIL`,`GIT_USER_NAME`,`TARGET_BRANCH`,`STATIC_SITE_REPO`，他们分别是git的用邮箱、用户名、待部署仓库的目标分支，待部署的目标仓库（你的静态页面的github地址）。这几个都是要我们去Appveyor里面设置的环境变量。\n\n#### 5. Appveyor的配置\n\n​\t\t回到Appveyor，点击New Project\n\n![image-20200223214015897](/../img/image-20200223214015897.png)\n\n​\t\t选择github里面你的博客源代码目录，点击右侧的Add，在新页面选择setting\n\n![image-20200223214102188](/../img/image-20200223214102188.png)\n\n​\t\t选择Environment，添加第四点所说的的环境变量\n\n​\t\t![image-20200223215652016](/../img/image-20200223215652016.png)\n\n​\t\t点击Save保存好配置。\n\n​\t\t之后，你只要把你的博客源代码推送到远程仓库之后，Appveyor会自动检测到你的推送并进行自动化部署。类似这样：\n\n​\t\t![image-20200223220116830](/../img/image-20200223220116830.png)\n\n​\t\t\t并且可以再你的源代码仓库里面查看是否部署成功：\n\n![image-20200223220259404](/../img/image-20200223220259404.png)\t\n\n​\t\t\t\t\n\n#### 6. 对Coding进行自动部署\n\n​\t\t来到Coding的[官网](https://coding.net/)，点击个人版登录，新建一个DevOps项目，建议项目名称跟你的用户名一致。在右侧的“构建与部署”处选择静态网站，选择立即发布静态网站，网站名称随意。\n\n​\t\t然后进入到个人设置，点击访问令牌\n\n![image-20200223221358546](/../img/image-20200223221358546.png)\n\n​\t\t这个类似于github的Access_Token,在这里我也是把权限全给了。\n\n​\t\t创建完成后记住令牌和令牌用户名。回到github的博客源代码仓库，选择上方的Actions，这个也就是github的Ci，选择**Set up a workflow yourself** \n\n![image-20200223221848554](/../img/image-20200223221848554.png)\n\n​\t\t在出现的编辑窗口里面，用下面的文本替换掉里面的内容（知乎上的一个大佬的配置）\n\n```yaml\nname: 自动部署 Hexo\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps:\n      - name: 开始运行\n        uses: actions/checkout@v1\n\n      - name: 设置 Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: 安装 Hexo CI\n        run: |\n          export TZ='Asia/Shanghai'\n          npm install hexo-cli -g\n      - name: 缓存\n        uses: actions/cache@v1\n        id: cache-dependencies\n        with:\n          path: node_modules\n          key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}}\n\n      - name: 安装插件\n        if: steps.cache-dependencies.outputs.cache-hit != 'true'\n        run: |\n          npm install\n      - name: 部署博客\n        run: |\n          hexo clean && hexo g\n          cd ./public\n          git init\n          git config user.name \"${{secrets.GIT_NAME}}\"\n          git config user.email \"${{secrets.GIT_EMAIL}}\"\n          git add .\n          git commit -m \"Update\"\n          git push --force --quiet \"https://${{secrets.CD_TOKEN}}@${{secrets.CD_REF}}\" master:master\n```\n\n​\t\t其中，以`secrets.`开头的四个变量是需要我们去设置的环境变量。 点击右边的Start commit保存。\n\n​\t\t我们进入源码仓库的环境变量设置，其位置如下：\n\n​\t\t![image-20200223222546211](/../img/image-20200223222546211.png)\n\n​\t\t这四个变量的意思分别如下表所示：\n\n|   变量    |              意思               |\n| :-------: | :-----------------------------: |\n| GIT_NAME  |           git的用户名           |\n| GIT_EMAIL |            git的邮箱            |\n|  CD_REF   |   coding的静态页面的仓库地址    |\n| CD_TOKEN  | coding的令牌用户名:coding的令牌 |\n\n其中CD_REF在你的Coding的右上方可以看到，改成ssh之后@后面的就是CD_REF了。\n\n![image-20200223223844299](/../img/image-20200223223844299.png)\n\n以后我们每次写完文章，直接git三连就可以自动化部署到两个静态页面托管仓库了。\n\n#### 7. 域名绑定\n\n​\t\t我们可以对域名的dns解析记录进行修改，实现国内用户访问的是coding上的页面，国外用户访问github上的页面。\n\n​\t\t一图流：\n\n​\t\t![image-20200223225143011](/../img/image-20200223225143011.png)\n\n​\t\t\t如果你的coding站点无法申请到证书，请暂停下境外的解析。\n\n​\t\t-完","tags":["Hexo","没有用的知识","自动化部署"]},{"title":"基于4412的opencv的移植(附带contrib)","url":"/2020/02/20/基于4412的opencv的移植-附带contrib/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 18.04LTS 64位\n\n#### 使用的工具\n\n1. 2013版的交叉编译工具(arm-2013.05-24-arm-none-linux-gnueabi)\n2. opencv_3.4.9\n3. opencv_contrib_3.4.9\n4. cmake-gui\n\n#### 问题\n\n1. 放假之前用的虚拟机被我删除了，里面的文件都没了。\n2. 开发板的文件系统被我折腾坏了\n3. 需要重新移植opencv\n\n#### 解决过程：\n\n##### 1. 下载所需软件以及源代码\n\n​\t\t首先下载好我们需要使用到的各个文件，他们的下载链接如下所示：\n\n```\narm-2013.05-24-arm-none-linux-gnueabi\t\t链接：http://pan.baidu.com/s/1i3gNttF\nopencv_3.4.9\t链接：https://github.com/opencv/opencv/archive/3.4.9.tar.gz\nopencv_contrib_3.4.9 链接：https://github.com/opencv/opencv_contrib/archive/3.4.9.tar.gz\n```\n\n至于cmake-gui的话，如果你使用的是ububtu，直接在终端输入`sudo apt install cmake-gui`即可。\n\n将交叉编译器解压好，这里我的是`/home/gukki/baidunetdiskdownload/arm-2013.05/`\n\n将下载并解压好的两份源代码放在同一个目录。\n\n##### 2. 使用cmake-gui进行交叉编译\n\n​\t\t打开cmake，如下图所示：（只截取了上半部分）\n\n![image-20200220202805847](/../img/image-20200220202805847.png)\n\n​\t\t第一行是要求你输入你的opencv的源代码的绝对路径，在这里我的路径是`/home/gukki/OpenCv/Source_Code/opencv-3.4.9`，第二行要求你填写配置好的源代码的保存路径。在这里，我的是`/home/gukki/OpenCv/Process_Code`。\n\n​\t\t填写完毕之后点击`Configure`，cmake要求你选择编译工具，由于我们是交叉编译，我们选择最后一项。点击下一步之后如下图所示：\n\n![image-20200220203339941](/../img/image-20200220203339941.png)\n\n​\t\t其中`Operating System`顾名思义，操作系统，我们的开发板上用的是Linux，就写上吧。\n\n`C`要求你指定好交叉编译器的C编译器，也就是arm-gcc的所在地。\n\n`C++`同理，也是要求你填上arm-g++的所在地，而`Target Root`填写上你交叉编译器的目录。\n\n​\t\t填写完成之后点击完成。\n\n​\t\t配置完成之后应该会是一片红色，并且左下角的文本显示区域有一句`Configuring done`。\n\n我们对我们的需求进行对opencv的裁剪：\n\n> 在搜索栏区域输入JPEG,勾选上`BUILD_JPEG`  \n>\n> 输入PNG,勾选上`BULID_PNG`\n>\n> 输入nonfree，勾选上\n>\n> 输入gtk，取消勾选，因为我们用不上图形界面\n>\n> 输入zlib，勾选上\n>\n> 输入extra，在`Value`一栏上点击右边的三个点，定位好你的`opencv_contrib`的`moudules`文件夹。\n>\n> 输入prefix，输入你想安装到的文件夹路径。等会`make install`时会安装到这里。    \n\n​\t\t配置完成之后点击`Configure`，此时你应该要下载一些有关附加模块的一些文件，可能需要很久，等不及的就不去配置extra。下载完成之后，可以再次对额外模块进行裁剪，根据你的需求来定。裁剪完成之后，再次点击`Configure`，应该不会出现红色了。\n\n点击`Generate`生成工程文件。  \n\n##### 3.编译文件\n\n​\t\t进入你的配置好的源代码的文件夹，在此处打开终端，输入`make`开始编译，根据自身虚拟机配置情况，可在后面加上`-j线程数`这个参数，我给虚拟机分配了8个核心，所以我编译速度比较快，只用了5分钟左右。如果你什么都没加，预计时间可能是半小时到一小时左右。中间可能有些警告，无须理会。只要没停下来就好。\n\n![image-20200220210124846](/../img/image-20200220210124846.png)\n\n可以看到处理器是被吃满的。  \n\n​\t\t编译完成后输入`make install`，可能需要你加个`sudo`什么的....\n\n​\t\t安装完成之后可以去设定的`prefix`文件夹去看看。应该长这样：\n\n![image-20200220210712344](/../img/image-20200220210712344.png)\n\n​\t\t其中`lib`里面是我们编译好的库文件，使用`file`命令查看类型：\n\n![image-20200220210841342](/../img/image-20200220210841342.png)\n\n​\t\t成功了大半了！\n\n##### 4. 移植到开发板上\n\n​\t\t将`lib`文件夹里面的所有文件全部传到开发板的`/lib`，目录下面，使用`nfs`速度会快很多。\n\n​\t\t由于我们使用了较新版本的`arm_gcc`编译工具链，我们还需要把交叉编译工具链里面的`libstdc++.so,libstdc++.so.6,libstdc++6.0.17`一起复制过去并覆盖。他们位于`arm-2013.05/arm-none-linux-gnueabi/libc/usr/lib/`这个地方。\n\n##### 5. 虚拟机编译设置\n\n​\t\t为了让虚拟机知道opecv的头文件和库文件的位置，我们需要借助一个叫做`pkg-config` 的软件， 安装也是可以用`apt`来安装的。我们找到opencv库文件夹里面的pkgconfig文件夹，打开你的shell的配置文件，我使用的是`zsh`所以打开`.zshrc`加入以下的两句话句话：\n\n```\nPKG_CONFIG_PATH=/home/gukki/OpenCv/_Install/lib/pkgconfig/:$PKG_CONFIG_PATH\nexport PKG_CONFIG_PATH\n```\n\n​\t\t自行替换你的pkgconfig文件夹位置。\n\n​\t\t使用`source`命令让更改生效，输入`pkg-config --cflags --libs opencv`，应该会出现一大坨东西，如下所示：\n\n![image-20200220212101215](/../img/image-20200220212101215.png)\n\n##### 6. 测试与简化\n\n​\t\t写一个非常简单的程序，来测试下吧：\n\n```c++\n#include<opencv2/opencv.hpp>\nusing namespace cv;\nint main()\n{\n  Mat m;\n  return 0;\n}\n```\n\n​\t\t保存为`T.cpp`，使用如下命令进行编译：\n\n```shell\narm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` T.cpp -lpthread -lrt -ldl \n```\n\n​\t\t应该只有一个警告，不需要理会。\n\n​\t\t生成的`a.out`文件拷贝到开发板，给予权限。运行之后应该什么效果都没有，也没有任何报错。那就是行了。你可以试试更加复杂的程序了。但是不能有任何跟界面有关的函数出现比如`imshow`，`waitkey`等等，否则会报错。（因为我裁剪掉了）你也可以自行尝试如何让他们使用，有更好的想法可以告诉我！\n\n​\t\t每次编译都要打那么长的代码，有没有方法可以简化？\n\n​\t\t可以使用`alias`命令来进行简化，我的就是：\n\n```shell\nalias armcv=\"arm-none-linux-gnueabi-g++ `pkg-config --cflags --libs opencv` -lpthread -ldl -lrt\"\n```\n\n​\t\t同样的，写到你自己的shell的配置文件里面。\n\n​\t\t完-\n\n​\t\t","tags":["嵌入式","软件移植"]},{"title":"4412的wifi驱动以及管理软件的移植","url":"/2020/02/20/4412的wifi驱动以及管理软件的移植/","content":"\n#### 平台\n\n1. UP-Tech 4412\n2. Kubuntu 64位  \n\n#### 问题\n\n1. 给的pdf上面的wifi模块的型号不对\n\n   > 它给我的是**rt8723bu**这个型号的驱动，实际上开发板上搭载的是![image-20200219235946818](/../img/image-20200219235946818.png)\n   >\n   > 这个型号的驱动\n\n2. 由于缺少`wpa_supplicant`这个管理软件，wifi无法连接到加密的网络\n\n     \n\n   \n\n #### 解决过程\n\n​\t\t我仔细地查看开发板，发现开发板搭载的是`rtl8188eus`这个型号的无线模块。知道是什么型号的就好办了，直接开始移植吧。\n\n​\t\t我先从google上找到了驱动源代码的[github](https://github.com/quickreflex/rtl8188eus)，clone下载之后，先对`Makefile`进行修改，由于它默认是i386平台，我们需要先对它进行屏蔽，并加入我们的设备。如下图所示：\n\n![image-20200220001655792](/../img/image-20200220001655792.png)\n\n![image-20200220001636696](/../img/image-20200220001636696.png)\n\n其中`CONFIG_PLATFORM_ARM_Exynos4412=y`是我们新添加的设备。\n\n​\t\t在1690行附近加入一段判断语句：\n\n```shell\nifeq ($(CONFIG_PLATFORM_ARM_Exynos4412), y)                                   \nEXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN                                  \n ARCH := arm                                                 \nCROSS_COMPILE := arm-none-linux-gnueabi-                                  \nKVER:=3.5.0                                                 \nKSRC :=/home/gukki/HostFiles/A9/SRC/kernel/linux-3.5.0-rc6/                         \nMODULE_NAME :=wlan                                             \nendif\n```\n\n​\t\t注意`KVER`是你的内核版本号，`KSRC`是你的交叉编译好的内核目录。\n\n​\t\t保存退出之后，直接`make`即可。生成的`wlan.ko`可通过minicom进行传输到开发板上，开发板上使用`insmod wlan.ko`来安装驱动。\n\n​\t\t驱动安装完成之后使用`ifconfig -a`来进行查看自己的无线网卡的名字，并且使用`ifconfig 无线网卡名字 up`来进行启用网卡。\n\n​\t\t驱动完成安装之后，运行`iwconfig`应该如下所示：\n\n![image-20200220011149442](/../img/image-20200220011149442.png)\n\n-----------------------------------------------------------------------------------------------------------------------------------\n\n​\t\t驱动安装完成之后，我发现这模块只能连接开放的wifi，进过一番google之后发现，我还需要移植一个名为[**wpa_supplicant**](https://w1.fi/releases/wpa_supplicant-0.7.2.tar.gz)   的软件来进行管理。而这个软件又依赖于[**openssl**](https://ftp.openssl.org/source/old/0.9.x/openssl-0.9.8e.tar.gz)这个库，索性一次全部搞定吧。\n\n​\t\t这里我的wpa版本是0.7.2,ssl版本是0.9.8.e。先从网上把他们下载下来。我将他们都解压到一个文件夹里。openssl的移植需要wpa提供的补丁文件。\n\n​\t\t执行命令:\n\n​\t\t\t`cp wpa_supplicant-0.7.2/patches/openssl-0.9.8e-tls-extensions.patch ./openssl-0.9.8e`\n\n​\t\t\t`cd openssl-0.9.8e`\n\n​\t\t\t` patch -p1 < openssl-0.9.8e-tls-extensions.patch`\n\n​\t\t创建一个干净的文件夹，我的路径是`/home/gukki/Cross_Code/Cross/openssl/`，在openssl-0.9.8目录里面运行`Configure`脚本来进行配置`Makefile`：\n\n```shell\n\t\t./Configure linux-elf-arm -DL_EDNIAN linux:'arm-none-linux-gnueabi-gcc' shared --prefix=/home/gukki/Cross_Code/Cross/openssl/ -lcrypto\n```\n\n​\t\t配置完成之后就可以`make && make install`了。生成的动态库文件在openssl/lib里面。  \n\n​\t\t接下来进行wpa的移植。  \n\n​\t\t进入wpa的源代码目录，修改`Makefile`文件，注释掉第一和第三行，并将CC改为你的交叉编译器，\n\n在\n  `  CFLAGS += -I../src`\n  `  CFLAGS += -I../src/utils `\n    下添加：\n  `  CFLAGS += -I/home/gukki/Cross_Code/Cross/openssl/include/`\n\n修改\n   ` LIBS += -lssl`\n    为\n    `LIBS += -lssl -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n修改\n   `LIBS_p += -lcrypto`\n    为\n `   LIBS_p += -lcrypto -L/home/gukki/Cross_Code/Cross/openssl/lib/`\n\n​\t\t保存并退出，将目录下面的`defconfig`复制为`.config`并执行`make`\n\n​\t\t编译完成之后，将目录下面的`wpa_supplicant`和`wpa_cli`文件拷贝到开发板的`/bin`目录下面。\n\n------------------\n\n​\t\t为了连接上加密的wifi，还需要在开发板的`/etc`目录下面添加wpa-psk-tkip.conf这一配置文件。\n\n我的配置文件如下所示：\n\n```\n WPA-PSK/TKIP\n        ctrl_interface=/var/run/wpa_supplicant\n        network={\n        ssid=\"****\"\n        key_mgmt=WPA-PSK\n        proto=WPA RSN\n        pairwise=CCMP\n        group=CCMP\n        psk=\"***\"\n        }\n\n```\n\n​\t\t其中ssid是你的wifi名字，psk是你的密码。\n\n​\t\t在开发板内创建wpa程序的运行目录：`mkdir /var/run/wpa_supplicant -p`\n\n​\t\t平时使用`wpa_supplicant -B -i wlan0 -c /etc/wpa-psk-tkip.conf`即可连接到wifi。\n\n​\t\t连接到之后需要自己更改ip地址和默认网关。具体操作请自行搜索。","tags":["嵌入式","驱动移植","软件移植"]}]